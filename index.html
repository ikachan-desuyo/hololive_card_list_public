<!DOCTYPE html>
<html lang="ja">
<!-- Version: 2.0.0 -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>ホロライブカードゲーム管理ツール</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    .container {
      max-width: 600px;
      width: 90%;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      padding: 40px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    h1 {
      font-size: 2.2em;
      margin: 20px 0;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-weight: bold;
    }

    .subtitle {
      font-size: 1.1em;
      color: #666;
      margin-bottom: 40px;
      line-height: 1.6;
    }

    .menu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .menu-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 30px 20px;
      text-decoration: none;
      color: #333;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    .menu-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s;
    }

    .menu-card:hover::before {
      left: 100%;
    }

    .menu-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
      border-color: #667eea;
    }

    .menu-icon {
      font-size: 3em;
      margin-bottom: 15px;
      display: block;
    }

    .menu-title {
      font-size: 1.4em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .menu-description {
      font-size: 0.95em;
      color: #666;
      line-height: 1.5;
    }

    .footer {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      color: #888;
      font-size: 0.9em;
    }

    /* モバイル対応 */
    @media (max-width: 768px) {
      .container {
        padding: 30px 20px;
        margin: 20px;
      }

      h1 {
        font-size: 1.8em;
      }

      .subtitle {
        font-size: 1em;
      }

      .menu-grid {
        grid-template-columns: 1fr;
      }

      .menu-card {
        padding: 25px 15px;
      }

      .menu-icon {
        font-size: 2.5em;
      }

      .menu-title {
        font-size: 1.2em;
      }
      
      /* モバイル版のみで画像一括DLボタンを表示 */
      .mobile-only {
        display: inline-block !important;
      }
    }

    /* デスクトップ版では画像一括DLボタンを非表示 */
    @media (min-width: 769px) {
      .mobile-only {
        display: none !important;
      }
    }

    /* ダークモード対応 */
    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      }

      .container {
        background: rgba(44, 62, 80, 0.95);
        color: #ecf0f1;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .menu-card {
        background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        color: #ecf0f1;
      }

      .menu-card:hover {
        border-color: #3498db;
      }

      .menu-title {
        color: #ecf0f1;
      }

      .menu-description {
        color: #bdc3c7;
      }

      .subtitle {
        color: #bdc3c7;
      }

      h1 span {
        color: #95a5a6 !important;
      }

      .footer {
        color: #95a5a6;
        border-top-color: rgba(255, 255, 255, 0.1);
      }
    }

    /* 更新確認ボタンのスタイル */
    #updateCheckBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }

    #updateCheckBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* 画像一括DLボタンのスタイル */
    #imageBulkDownloadBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
    }

    #imageBulkDownloadBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* モーダルアニメーション */
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    /* ダークモード時のモーダルスタイル */
    @media (prefers-color-scheme: dark) {
      #imageDownloadModal > div > div {
        background: #34495e !important;
        color: #ecf0f1 !important;
        border: 1px solid #2c3e50 !important;
      }

      #imageDownloadModal h3 {
        color: #ecf0f1 !important;
      }

      #imageDownloadModal > div > div > div:nth-child(2) {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }

      #imageDownloadModal > div > div > div:nth-child(3) {
        background: #f39c12 !important;
        border: 1px solid #e67e22 !important;
        color: #2c3e50 !important;
      }

      #imageDownloadModal #progressText {
        color: #bdc3c7 !important;
      }

      #imageDownloadModal #downloadProgress {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ホロライブカードゲーム<br>管理ツール
      <span style="font-size: 0.4em; color: #999; display: block; margin-top: 5px; font-weight: normal;" id="versionDisplay">[v2.0.0]</span>
    </h1>

    <div class="menu-grid">
      <div class="menu-card" onclick="safeNavigate('card_list.html')" style="cursor: pointer;">
        <span class="menu-icon">🃏</span>
        <div class="menu-title">カード一覧</div>
        <div class="menu-description">
          全カードの一覧表示・検索・フィルタリング機能。所持状況の管理やCSVでのデータ管理が可能です。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('binder_collection.html')" style="cursor: pointer;">
        <span class="menu-icon">📚</span>
        <div class="menu-title">バインダーコレクション</div>
        <div class="menu-description">
          複数のバインダーを管理。お気に入りの表紙画像を設定して、テーマ別にカードをコレクションできます。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('holoca_skill_page.html')" style="cursor: pointer;">
        <span class="menu-icon">🗂️</span>
        <div class="menu-title">カード詳細検索</div>
        <div class="menu-description">
          詳細な条件でカードを検索。スキル・能力・コストなど様々な条件で絞り込めます。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('deck_builder.html')" style="cursor: pointer;">
        <span class="menu-icon">⚔️</span>
        <div class="menu-title">デッキ作成</div>
        <div class="menu-description">
          戦略的なデッキを構築。カードの組み合わせを考えながら最適なデッキを作成できます。
        </div>
      </div>
    </div>

    <!-- 更新確認ボタン -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="updateCheckBtn" onclick="checkForUpdates()" style="
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        🔄 更新確認
      </button>
      <!-- モバイル版のみ画像一括DLボタンを表示 -->
      <button onclick="showImageDownloadDialog()" id="imageBulkDownloadBtn" class="mobile-only" style="
        background: linear-gradient(45deg, #007bff, #0056b3);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        📥 画像一括DL
      </button>
      <div id="updateStatus" style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.3; max-width: 400px; white-space: pre-line;"></div>
    </div>

    <div class="footer">
      <p>© 2025 ikachan-desuyo - Hololive Card Game Management Tool</p>
      <p>このツールは非公式のファンメイドツールです</p>
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 0.85em; color: #888; line-height: 1.4;">
        <p><strong>権利表記・免責事項</strong></p>
        <p>「ホロライブ」「hololive」は株式会社カバーの商標です。</p>
        <p>「ホロライブオフィシャルカードゲーム」は株式会社ブシロードの商標です。</p>
        <p>このツールは株式会社カバー・株式会社ブシロードとは無関係の非公式ファンメイドツールです。</p>
        <p>カードデータの著作権は各権利者に帰属します。</p>
        <p>このツールの使用により生じた損害について、作成者は一切の責任を負いません。</p>
      </div>
      <p id="offline-status" style="font-size: 0.8em; margin-top: 10px;"></p>
    </div>
  </div>

  <!-- 画像一括ダウンロード確認ダイアログ -->
  <div id="imageDownloadModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:2000; backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);">
    <div style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
      <div style="background:white; padding:30px; border-radius:10px; max-width:500px; width:90%; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3); animation: modalSlideIn 0.3s ease-out;">
        <h3 style="margin-top:0; color:#333;">📥 画像一括ダウンロード</h3>
        <div style="margin:20px 0; padding:15px; background:#f5f5f5; border-radius:5px; text-align:left;">
          <p style="margin:5px 0;"><strong>対象画像数:</strong> <span id="totalImageCount">-</span> 枚</p>
          <p style="margin:5px 0;"><strong>推定サイズ:</strong> <span id="estimatedSize">計算中...</span></p>
          <p style="margin:5px 0;"><strong>現在のキャッシュ:</strong> <span id="currentCacheInfo">確認中...</span></p>
          <p style="margin:5px 0; font-size:0.9em; color:#666;">※ 1枚あたり約150-200KBで計算</p>
        </div>
        <div style="margin:15px 0; padding:10px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:5px; font-size:0.9em; color:#856404;">
          <strong>⚠️ 注意事項</strong><br>
          • カード一覧ページのデータを利用して画像をダウンロードします<br>
          • ダウンロードには時間がかかる場合があります<br>
          • モバイルデータ通信の場合、通信量にご注意ください<br>
          • ダウンロード中はページを閉じないでください
        </div>
        <div id="downloadProgress" style="display:none; margin:15px 0;">
          <div style="background:#e9ecef; border-radius:10px; height:20px; overflow:hidden;">
            <div id="progressBar" style="background:linear-gradient(90deg, #007bff 0%, #28a745 100%); height:100%; width:0%; transition:width 0.3s;"></div>
          </div>
          <p id="progressText" style="margin:10px 0; font-size:0.9em; color:#666; white-space:pre-line;">準備中...</p>
        </div>
        <div style="margin-top:20px;">
          <button onclick="startImageDownload()" id="startDownloadBtn" style="background:#007bff; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px; transition: all 0.3s ease;">📥 ダウンロード開始</button>
          <button onclick="clearImageCache()" id="clearCacheBtn" style="background:#dc3545; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px;">🗑️ キャッシュ削除</button>
          <button onclick="hideImageDownloadDialog()" id="cancelDownloadBtn" style="background:#6c757d; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; font-size:16px;">キャンセル</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ✅ Service Worker との通信機能
    async function sendMessageToSW(type, data = null) {
      if (!navigator.serviceWorker.controller) return null;

      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };

        navigator.serviceWorker.controller.postMessage(
          { type, data },
          [messageChannel.port2]
        );
      });
    }

    // ✅ バージョン情報を取得
    async function getVersionInfo() {
      return await sendMessageToSW('GET_VERSION_INFO');
    }

    // ✅ 更新メッセージを取得
    async function getUpdateMessage() {
      return await sendMessageToSW('GET_UPDATE_MESSAGE');
    }

    // ✅ 古いページをチェック
    async function checkOutdatedPages() {
      return await sendMessageToSW('CHECK_OUTDATED_PAGES');
    }

    // Service Worker registration with centralized version management
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', {
          updateViaCache: 'none' // モバイル向け：キャッシュを使わず常に最新をチェック
        })
          .then((registration) => {
            console.log('SW registered: ', registration);

            // モバイル向け：即座に更新チェック
            registration.update();

            // ✅ 新しいバージョン管理システムで更新確認
            const checkForUpdates = async () => {
              try {
                // Service Worker が準備できるまで待機
                if (!navigator.serviceWorker.controller) {
                  setTimeout(checkForUpdates, 1000);
                  return;
                }

                const updateMessage = await getUpdateMessage();
                if (!updateMessage) return;

                if (confirm(updateMessage.data.message)) {
                  // 全キャッシュクリア後にリロード
                  const cacheNames = await caches.keys();
                  await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                  window.location.href = window.location.href + '?v=' + Date.now();
                }
              } catch (error) {
                console.error('Version check error:', error);
              }
            };

            // Check for waiting service worker with new system
            if (registration.waiting) {
              console.log('SW update available');
              setTimeout(checkForUpdates, 500);
            }

            // Listen for updates with new system
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    setTimeout(checkForUpdates, 500);
                  }
                });
              }
            });

            // Listen for controller change
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              window.location.reload();
            });
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    // モバイル向け：定期的な更新チェック（5分間隔）
    if ('serviceWorker' in navigator && /Mobi|Android/i.test(navigator.userAgent)) {
      setInterval(async () => {
        try {
          const registration = await navigator.serviceWorker.getRegistration();
          if (registration) {
            await registration.update();
            console.log('Mobile: Periodic update check completed');
          }
        } catch (error) {
          console.log('Mobile: Periodic update check failed:', error);
        }
      }, 5 * 60 * 1000); // 5分間隔
    }

    // Online/Offline status
    function updateOnlineStatus() {
      const statusElement = document.getElementById('offline-status');
      if (navigator.onLine) {
        statusElement.textContent = '🟢 オンライン - 最新データを取得中';
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.textContent = '🔴 オフライン - キャッシュデータを使用中';
        statusElement.style.color = '#F44336';
      }
    }

    // Update status on page load and network changes
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    window.addEventListener('load', updateOnlineStatus);

    // Manual update check function
    let serviceWorkerRegistration = null;

    // Store registration for manual update checks
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            serviceWorkerRegistration = registration;
            console.log('SW registered: ', registration);
            // ... existing code above
          });
      });
    }

    async function checkForUpdates() {
      const statusEl = document.getElementById('updateStatus');
      const btnEl = document.getElementById('updateCheckBtn');

      if (!navigator.onLine) {
        statusEl.textContent = '⚠️ オフライン状態では更新確認できません';
        statusEl.style.color = '#ff9800';
        return;
      }

      try {
        btnEl.disabled = true;
        btnEl.textContent = '🔄 確認中...';
        statusEl.textContent = 'バージョン情報を確認中...';
        statusEl.style.color = '#2196f3';

        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          const messageChannel = new MessageChannel();

          // タイムアウト設定（10秒）
          const timeout = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Service Worker timeout')), 10000)
          );

          // Service Workerからのレスポンスを待機
          const checkPromise = new Promise((resolve, reject) => {
            messageChannel.port1.onmessage = (event) => {
              if (event.data.type === 'VERSION_MISMATCH_RESPONSE') {
                resolve(event.data.data);
              } else if (event.data.type === 'VERSION_MISMATCH_ERROR') {
                reject(new Error(event.data.error));
              }
            };
          });

          // 詳細バージョンチェック要求を送信
          navigator.serviceWorker.controller.postMessage(
            { type: 'CHECK_VERSION_MISMATCH' },
            [messageChannel.port2]
          );

          // レスポンス待機（タイムアウト付き）
          const versionCheckResult = await Promise.race([checkPromise, timeout]);

          if (versionCheckResult.hasUpdates) {
            // バージョン不一致の詳細情報を生成
            let detailMessage = '🚀 バージョンの不一致が検出されました:\n\n';
            detailMessage += `📊 アプリバージョン: v${versionCheckResult.currentAppVersion}\n`;
            detailMessage += `🕐 チェック時刻: ${new Date(versionCheckResult.timestamp).toLocaleString('ja-JP')}\n\n`;

            versionCheckResult.outdatedPages.forEach(pageInfo => {
              detailMessage += `📄 ${pageInfo.page}:\n`;
              detailMessage += `  ┣ 期待バージョン: v${pageInfo.expectedVersion}\n`;
              detailMessage += `  ┣ 実際のバージョン: v${pageInfo.actualVersion || '不明'}\n`;
              detailMessage += `  ┣ キャッシュバージョン: v${pageInfo.cachedVersion || 'なし'}\n`;

              // ミスマッチの理由を日本語で説明
              let reasonText = '';
              switch(pageInfo.reason) {
                case 'expected_vs_actual_mismatch':
                  reasonText = '期待バージョンと実際バージョンが不一致';
                  break;
                case 'actual_vs_cached_mismatch':
                  reasonText = '実際バージョンとキャッシュバージョンが不一致';
                  break;
                case 'actual_version_not_found':
                  reasonText = '実際のバージョン情報が見つかりません';
                  break;
                case 'no_cached_version':
                  reasonText = 'キャッシュにバージョン情報がありません';
                  break;
                default:
                  reasonText = pageInfo.reason;
              }
              detailMessage += `  ┗ 理由: ${reasonText}\n\n`;
            });

            statusEl.innerHTML = `🚀 更新が利用可能です (${versionCheckResult.outdatedPages.length}ページ)<br><small>詳細情報を確認してください</small>`;
            statusEl.style.color = '#4caf50';
            console.log('Version check details:', versionCheckResult);

            setTimeout(() => {
              if (confirm(detailMessage + 'バージョン不一致のページを更新してアプリケーションを再読み込みしますか？')) {
                statusEl.innerHTML = `⚡ 更新中...<br><small>対象ページのキャッシュをクリア中</small>`;
                statusEl.style.color = '#ff9800';

                // バージョン不一致のページのみをターゲットにした更新処理
                console.log('Starting targeted cache clear and update for outdated pages...');

                // Service Workerに強制更新を要求（対象ページのみ）
                if (navigator.serviceWorker.controller) {
                  navigator.serviceWorker.controller.postMessage({
                    type: 'FORCE_UPDATE',
                    outdatedPages: versionCheckResult.outdatedPages.map(p => p.page)
                  });
                }

                // 対象ページのキャッシュクリア + 必要最小限の全体キャッシュクリア
                if ('caches' in window) {
                  caches.keys().then(cacheNames => {
                    return Promise.all(cacheNames.map(cacheName => {
                      console.log('Deleting cache for outdated pages:', cacheName);
                      return caches.delete(cacheName);
                    }));
                  }).then(() => {
                    console.log('Caches cleared for outdated pages');
                    statusEl.innerHTML = `🔄 アプリケーションを再読み込み中...<br><small>更新されたページを反映します</small>`;
                    // Service Workerの更新を待つ
                    return new Promise(resolve => setTimeout(resolve, 1000));
                  }).then(() => {
                    // 対象ページの更新を反映するためのリロード
                    console.log('Performing targeted reload for updated pages...');
                    if (window.location.reload) {
                      window.location.reload(true); // 強制リロード
                    } else {
                      window.location.href = window.location.href + '?t=' + Date.now();
                    }
                  }).catch(error => {
                    console.error('Targeted cache clear failed, forcing reload anyway:', error);
                    window.location.href = window.location.href + '?t=' + Date.now();
                  });
                } else {
                  // キャッシュAPIが使えない場合のフォールバック
                  window.location.href = window.location.href + '?t=' + Date.now();
                }
              } else {
                // キャンセル時は元の状態に戻す
                statusEl.innerHTML = `ℹ️ 更新がキャンセルされました<br><small>必要な時に再度確認してください</small>`;
                statusEl.style.color = '#2196f3';
              }
            }, 2000);
          } else {
            // 最新の場合、比較したバージョン情報を詳細表示
            let versionDetails = `✅ 最新バージョン v${versionCheckResult.currentAppVersion}<br>`;
            versionDetails += `<small>📊 各ページのバージョン情報:<br><br>`;

            if (versionCheckResult.allPages && versionCheckResult.allPages.length > 0) {
              versionCheckResult.allPages.forEach(pageInfo => {
                const pageName = pageInfo.page.replace('.html', '');
                const expectedV = pageInfo.expectedVersion;
                const actualV = pageInfo.actualVersion;
                const status = expectedV === actualV ? '✅' : '⚠️';

                versionDetails += `${status} ${pageName}<br>`;
                versionDetails += `&nbsp;&nbsp;├ 最新: v${expectedV}<br>`;
                versionDetails += `&nbsp;&nbsp;└ 現在: v${actualV}<br><br>`;
              });
            } else {
              versionDetails += `全ページのバージョンが最新です`;
            }
            versionDetails += `</small>`;

            statusEl.innerHTML = versionDetails;
            statusEl.style.color = '#4caf50';
            setTimeout(() => {
              statusEl.textContent = '';
            }, 7000); // 表示時間を延長
          }
        } else {
          statusEl.textContent = '⚠️ Service Worker が利用できません';
          statusEl.style.color = '#ff9800';
        }

      } catch (error) {
        console.error('Update check failed:', error);
        statusEl.textContent = '❌ 更新確認に失敗しました: ' + error.message;
        statusEl.style.color = '#f44336';
      } finally {
        btnEl.disabled = false;
        btnEl.textContent = '🔄 更新確認';
      }
    }

    // セーフナビゲーション関数（フォールバック付き）
    function safeNavigate(url) {
      console.log('Attempting to navigate to:', url);
      
      // offline-utils.js が読み込まれているかチェック
      if (typeof window.navigateToPage === 'function') {
        console.log('Using offline-aware navigation');
        window.navigateToPage(url);
      } else {
        console.log('offline-utils.js not loaded, using fallback navigation');
        // フォールバック: 通常のナビゲーション
        if (navigator.onLine) {
          window.location.href = url;
        } else {
          // オフライン時の簡易チェック
          if (confirm('オフライン状態です。このページが利用できない可能性があります。\n移動しますか？')) {
            window.location.href = url;
          }
        }
      }
    }

    // 画像ダウンロード確認ダイアログを表示
    async function showImageDownloadDialog() {
      console.log('showImageDownloadDialog called');
      
      // モバイル版のみ表示（より厳密な判定）
      const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      console.log('isMobile check:', isMobile, 'window.innerWidth:', window.innerWidth);
      
      if (!isMobile) {
        console.log('Image bulk download is available only on mobile devices');
        alert('画像一括ダウンロードはモバイル版でのみ利用可能です。');
        return;
      }
      
      if (imageDownloadInProgress) {
        alert('画像ダウンロードが実行中です。しばらくお待ちください。');
        return;
      }

      console.log('Current cards array length:', cards.length);
      
      // カードデータを読み込み
      if (cards.length === 0) {
        console.log('Loading card data...');
        const loadedCards = await loadCardData();
        if (loadedCards.length === 0) {
          console.log('Failed to load card data');
          return; // データ読み込み失敗
        }
      }

      const modal = document.getElementById('imageDownloadModal');
      const totalImageCountEl = document.getElementById('totalImageCount');
      const estimatedSizeEl = document.getElementById('estimatedSize');
      const currentCacheInfoEl = document.getElementById('currentCacheInfo');
      const startBtn = document.getElementById('startDownloadBtn');
      
      // 画像数を計算
      const imageUrls = extractImageUrls();
      const totalCount = imageUrls.length;
      
      console.log(`Found ${totalCount} images to download`);
      
      if (totalCount === 0) {
        alert('ダウンロード対象の画像が見つかりませんでした。カードデータの読み込みを確認してください。');
        return;
      }
      
      // 推定サイズを計算（1枚あたり150-200KBで計算）
      const avgSizeKB = 175; // 平均サイズ
      const estimatedSizeMB = Math.round((totalCount * avgSizeKB) / 1024 * 10) / 10;
      
      totalImageCountEl.textContent = totalCount.toLocaleString();
      estimatedSizeEl.textContent = `約 ${estimatedSizeMB.toLocaleString()} MB`;
      
      // 詳細なキャッシュ状況を非同期で取得
      currentCacheInfoEl.textContent = '確認中...';
      startBtn.disabled = true;
      startBtn.textContent = '確認中...';
      
      checkCacheStatus().then(cacheStatus => {
        if (cacheStatus.cached === cacheStatus.total && cacheStatus.total > 0) {
          // 全てキャッシュ済み
          currentCacheInfoEl.innerHTML = `✅ <strong>全画像キャッシュ済み</strong> (${cacheStatus.cached}/${cacheStatus.total}枚)`;
          startBtn.disabled = true;
          startBtn.textContent = '📥 ダウンロード済み';
          startBtn.style.background = '#28a745';
        } else if (cacheStatus.cached > 0) {
          // 一部キャッシュ済み
          currentCacheInfoEl.innerHTML = `⚠️ <strong>一部キャッシュ済み</strong> (${cacheStatus.cached}/${cacheStatus.total}枚)<br>未キャッシュ: ${cacheStatus.uncached}枚`;
          startBtn.disabled = false;
          startBtn.textContent = `📥 残り${cacheStatus.uncached}枚をダウンロード`;
          startBtn.style.background = '#ffc107';
          startBtn.style.color = '#212529';
        } else {
          // キャッシュなし
          currentCacheInfoEl.innerHTML = `❌ <strong>キャッシュなし</strong> (0/${cacheStatus.total}枚)`;
          startBtn.disabled = false;
          startBtn.textContent = '📥 ダウンロード開始';
          startBtn.style.background = '#007bff';
          startBtn.style.color = 'white';
        }
        
        // 推定ダウンロードサイズを未キャッシュ分のみで再計算
        if (cacheStatus.uncached > 0) {
          const uncachedSizeMB = Math.round((cacheStatus.uncached * avgSizeKB) / 1024 * 10) / 10;
          estimatedSizeEl.textContent = `約 ${uncachedSizeMB.toLocaleString()} MB (未キャッシュ分)`;
        } else if (cacheStatus.cached > 0) {
          estimatedSizeEl.textContent = `ダウンロード不要`;
        }
        
      }).catch(error => {
        console.error('Cache status error:', error);
        currentCacheInfoEl.textContent = '❌ 情報取得失敗';
        startBtn.disabled = false;
        startBtn.textContent = '📥 ダウンロード開始';
      });
      
      console.log('Showing modal');
      modal.style.display = 'block';
    }

    // 画像ダウンロード確認ダイアログを非表示
    function hideImageDownloadDialog() {
      const modal = document.getElementById('imageDownloadModal');
      
      if (imageDownloadInProgress) {
        const confirmClose = confirm('ダウンロードが実行中です。中断しますか？');
        if (!confirmClose) return;
        
        // 中断フラグを設定
        imageDownloadInProgress = false;
        console.log('Image download was cancelled by user');
      }
      
      modal.style.display = 'none';
      
      // プログレスをリセット
      resetDownloadProgress();
    }

    // カードデータから画像URLを抽出
    function extractImageUrls() {
      const imageUrls = [];
      const seenUrls = new Set();
      
      console.log('Cards array length:', cards.length);
      console.log('Sample card:', cards[0]);
      
      // カードデータがオブジェクト形式の場合、値を取得
      const cardArray = Array.isArray(cards) ? cards : Object.values(cards);
      
      for (const card of cardArray) {
        // image_url プロパティから画像URLを取得（データ構造に合わせて修正）
        const imageUrl = card.image_url || card.image;
        if (imageUrl && !seenUrls.has(imageUrl)) {
          imageUrls.push(imageUrl);
          seenUrls.add(imageUrl);
        }
      }
      
      console.log(`Extracted ${imageUrls.length} unique image URLs`);
      console.log('Sample image URL:', imageUrls[0]);
      return imageUrls;
    }

    // ダウンロード進捗をリセット
    function resetDownloadProgress() {
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      progressDiv.style.display = 'none';
      progressBar.style.width = '0%';
      progressText.textContent = '準備中...';
      startBtn.disabled = false;
      startBtn.textContent = '📥 ダウンロード開始';
      cancelBtn.textContent = 'キャンセル';
    }

    // 画像一括ダウンロード開始（card_list.jsのロジックを移植）
    async function startImageDownload() {
      if (imageDownloadInProgress) return;
      
      imageDownloadInProgress = true;
      
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      // UIを更新
      progressDiv.style.display = 'block';
      startBtn.disabled = true;
      startBtn.textContent = 'ダウンロード中...';
      cancelBtn.textContent = '中断';
      
      try {
        // キャッシュ状況をチェックして、未キャッシュの画像のみを対象にする
        progressText.textContent = 'キャッシュ状況を確認中...';
        const cacheStatus = await checkCacheStatus();
        
        if (cacheStatus.uncached === 0) {
          // 全てキャッシュ済み
          progressText.textContent = '✅ 全ての画像は既にキャッシュされています';
          startBtn.textContent = '✅ 完了';
          cancelBtn.textContent = '閉じる';
          alert('全ての画像は既にキャッシュされているため、ダウンロードの必要はありません。');
          return;
        }
        
        const imageUrls = cacheStatus.uncachedUrls; // 未キャッシュの画像のみ
        const totalCount = imageUrls.length;
        let successCount = 0;
        let failureCount = 0;
        
        console.log(`Starting download of ${totalCount} uncached images`);
        
        progressText.textContent = `未キャッシュ画像を事前読み込み中... (${totalCount}枚)`;
        
        // バッチサイズ（同時ダウンロード数）
        const batchSize = 3; // バッチサイズを小さくして安定性向上
        
        for (let i = 0; i < imageUrls.length; i += batchSize) {
          if (!imageDownloadInProgress) {
            console.log('Download was cancelled by user');
            break; // 中断された場合
          }
          
          const batch = imageUrls.slice(i, i + batchSize);
          console.log(`Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(imageUrls.length/batchSize)}`);
          
          const batchPromises = batch.map(async (url) => {
            return new Promise(async (resolve) => {
              try {
                const timeout = setTimeout(() => {
                  console.warn(`Timeout for: ${url}`);
                  resolve({ success: false, url, error: 'Timeout' });
                }, 15000); // 15秒タイムアウト
                
                // Service Workerがキャッシュに保存するようにfetchを実行
                const response = await fetch(url);
                
                clearTimeout(timeout);
                
                // レスポンス状態をチェック
                if (response.ok || response.type === 'opaque') {
                  console.log(`Successfully fetched: ${url} (status: ${response.status || 'opaque'})`);
                  resolve({ success: true, url, cached: true });
                } else {
                  console.warn(`Failed to fetch: ${url} - Status: ${response.status}`);
                  resolve({ success: false, url, error: `HTTP ${response.status}` });
                }
                
              } catch (error) {
                console.warn(`Fetch failed for: ${url} - ${error.message}`);
                
                // fetch失敗の場合、Imageオブジェクトでフォールバック
                try {
                  const img = new Image();
                  const imgTimeout = setTimeout(() => {
                    resolve({ success: false, url, error: 'Image load timeout' });
                  }, 10000);
                  
                  img.onload = () => {
                    clearTimeout(imgTimeout);
                    console.log(`Image fallback succeeded for: ${url}`);
                    resolve({ success: true, url, cached: false });
                  };
                  
                  img.onerror = () => {
                    clearTimeout(imgTimeout);
                    resolve({ success: false, url, error: 'Image load failed' });
                  };
                  
                  img.src = url;
                } catch (imgError) {
                  resolve({ success: false, url, error: `Both fetch and image failed: ${error.message}` });
                }
              }
            });
          });
          
          // バッチ実行
          const batchResults = await Promise.all(batchPromises);
          
          // 結果を集計
          batchResults.forEach(result => {
            if (result.success) {
              successCount++;
            } else {
              failureCount++;
              console.warn(`Failed: ${result.url} - ${result.error}`);
            }
          });
          
          // プログレス更新
          const progress = Math.round((successCount + failureCount) / totalCount * 100);
          progressBar.style.width = `${progress}%`;
          
          // 全体の進捗情報を表示（既キャッシュ + 新規ダウンロード）
          const totalCachedNow = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `${successCount + failureCount} / ${totalCount} 完了 (成功: ${successCount}, 失敗: ${failureCount})\n全体: ${totalCachedNow}/${grandTotal}枚がキャッシュ済み`;
          
          // 少し待機（サーバー負荷軽減）
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        if (imageDownloadInProgress) {
          // 完了メッセージ
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          
          if (failureCount === 0) {
            progressText.textContent = `✅ 新規画像のダウンロードが完了しました！ (${successCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
            alert(`画像一括ダウンロードが完了しました！\n\n新規ダウンロード: ${successCount}枚\n既存キャッシュ: ${cacheStatus.cached}枚\n合計: ${totalCachedFinal}/${grandTotal}枚\n\nオフラインでも画像が表示されるようになりました。`);
          } else {
            progressText.textContent = `⚠️ ダウンロード完了 (成功: ${successCount}枚, 失敗: ${failureCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
            alert(`画像一括ダウンロードが完了しました。\n\n新規成功: ${successCount}枚\n失敗: ${failureCount}枚\n既存キャッシュ: ${cacheStatus.cached}枚\n\n成功した画像はオフラインでも表示されます。`);
          }
          
          startBtn.textContent = '✅ 完了';
          cancelBtn.textContent = '閉じる';
        } else {
          // 中断された場合
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `❌ ダウンロードが中断されました (成功: ${successCount}枚, 失敗: ${failureCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
          startBtn.textContent = '中断済み';
          cancelBtn.textContent = '閉じる';
        }
        
      } catch (error) {
        console.error('Image download error:', error);
        progressText.textContent = '❌ ダウンロードエラーが発生しました';
        alert(`画像ダウンロード中にエラーが発生しました：${error.message}`);
        
        startBtn.textContent = '❌ エラー';
        cancelBtn.textContent = '閉じる';
      } finally {
        imageDownloadInProgress = false;
        startBtn.disabled = false;
      }
    }

    // 画像キャッシュを削除
    async function clearImageCache() {
      if (!confirm('画像キャッシュを削除しますか？\n\n削除後は再度ダウンロードが必要になります。')) {
        return;
      }

      const clearBtn = document.getElementById('clearCacheBtn');
      const originalText = clearBtn.textContent;
      
      try {
        clearBtn.disabled = true;
        clearBtn.textContent = '削除中...';
        
        // すべてのキャッシュを取得
        const cacheNames = await caches.keys();
        console.log('Available caches:', cacheNames);
        
        let deletedCount = 0;
        let totalSize = 0;
        
        // 画像関連のキャッシュエントリを削除
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          const requests = await cache.keys();
          
          for (const request of requests) {
            // 画像URLまたはhololive-official-cardgame.comのリクエストを削除
            if (request.url.includes('hololive-official-cardgame.com') ||
                request.url.includes('.jpg') ||
                request.url.includes('.png') ||
                request.url.includes('.jpeg') ||
                request.url.includes('.webp')) {
              
              const response = await cache.match(request);
              if (response) {
                const clonedResponse = response.clone();
                try {
                  // レスポンスサイズを推定（可能であれば）
                  const blob = await clonedResponse.blob();
                  totalSize += blob.size;
                } catch (e) {
                  // サイズ取得失敗は無視
                }
              }
              
              await cache.delete(request);
              deletedCount++;
              console.log('Deleted cached image:', request.url);
            }
          }
        }
        
        // サイズを人間が読める形式に変換
        const sizeText = totalSize > 0 ? 
          `約 ${(totalSize / (1024 * 1024)).toFixed(1)} MB` : 
          '不明';
        
        clearBtn.textContent = '✅ 削除完了';
        
        alert(`画像キャッシュを削除しました！\n\n削除した画像数: ${deletedCount}枚\n削除したサイズ: ${sizeText}\n\n次回表示時にはネットワークから画像を読み込みます。`);
        
        // UIをリセット
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
        
      } catch (error) {
        console.error('Cache clear error:', error);
        clearBtn.textContent = '❌ エラー';
        alert(`キャッシュ削除中にエラーが発生しました：${error.message}`);
        
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
      }
    }

    // キャッシュ状況を詳細チェック
    async function checkCacheStatus() {
      try {
        const imageUrls = extractImageUrls();
        const cacheNames = await caches.keys();
        
        let cachedUrls = new Set();
        let uncachedUrls = [];
        
        // すべてのキャッシュをチェック
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          
          for (const url of imageUrls) {
            const response = await cache.match(url);
            if (response) {
              cachedUrls.add(url);
            }
          }
        }
        
        // キャッシュされていないURLを特定
        for (const url of imageUrls) {
          if (!cachedUrls.has(url)) {
            uncachedUrls.push(url);
          }
        }
        
        return {
          total: imageUrls.length,
          cached: cachedUrls.size,
          uncached: uncachedUrls.length,
          cachedUrls: Array.from(cachedUrls),
          uncachedUrls: uncachedUrls
        };
        
      } catch (error) {
        console.error('Cache status check error:', error);
        return {
          total: 0,
          cached: 0,
          uncached: 0,
          cachedUrls: [],
          uncachedUrls: []
        };
      }
    }

    // 画像一括DL機能 - カード一覧ページと連携
    let imageDownloadInProgress = false;
    let cards = []; // カードデータをグローバルに保持

    // カードデータを動的に読み込み
    async function loadCardData() {
      try {
        const response = await fetch('json_file/card_data.json');
        if (!response.ok) throw new Error('カードデータの読み込みに失敗しました');
        const cardData = await response.json();
        
        // オブジェクトの場合は配列に変換
        cards = Array.isArray(cardData) ? cardData : Object.values(cardData);
        console.log(`Loaded ${cards.length} cards for image download`);
        console.log('Sample card:', cards[0]);
        return cards;
      } catch (error) {
        console.error('Card data loading error:', error);
        alert('カードデータの読み込みに失敗しました。ネットワーク接続を確認してください。');
        return [];
      }
    }
  </script>
  <!-- オフライン状態管理 -->
  <script src="js/offline-utils.js"></script>
</body>
</html>
