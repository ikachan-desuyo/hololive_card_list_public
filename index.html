<!DOCTYPE html>
<html lang="ja">
<!-- Version: 4.11.3 -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>ãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ç®¡ç†ãƒ„ãƒ¼ãƒ«</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    .container {
      max-width: 600px;
      width: 90%;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      padding: 40px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    h1 {
      font-size: 2.2em;
      margin: 20px 0;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-weight: bold;
    }

    .subtitle {
      font-size: 1.1em;
      color: #666;
      margin-bottom: 40px;
      line-height: 1.6;
    }

    .menu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .menu-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 30px 20px;
      text-decoration: none;
      color: #333;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    .menu-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s;
    }

    .menu-card:hover::before {
      left: 100%;
    }

    .menu-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
      border-color: #667eea;
    }

    .menu-icon {
      font-size: 3em;
      margin-bottom: 15px;
      display: block;
    }

    .menu-title {
      font-size: 1.4em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .menu-description {
      font-size: 0.95em;
      color: #666;
      line-height: 1.5;
    }

    .footer {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      color: #888;
      font-size: 0.9em;
    }

    /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    @media (max-width: 768px) {
      .container {
        padding: 30px 20px;
        margin: 20px;
      }

      h1 {
        font-size: 1.8em;
      }

      .subtitle {
        font-size: 1em;
      }

      .menu-grid {
        grid-template-columns: 1fr;
      }

      .menu-card {
        padding: 25px 15px;
      }

      .menu-icon {
        font-size: 2.5em;
      }

      .menu-title {
        font-size: 1.2em;
      }
      
      /* ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã®ã¿ã§ç”»åƒä¸€æ‹¬DLãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º */
      .mobile-only {
        display: inline-block !important;
      }
    }

    /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã§ã¯ç”»åƒä¸€æ‹¬DLãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º */
    @media (min-width: 769px) {
      .mobile-only {
        display: none !important;
      }
    }

    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œ */
    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      }

      .container {
        background: rgba(44, 62, 80, 0.95);
        color: #ecf0f1;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .menu-card {
        background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        color: #ecf0f1;
      }

      .menu-card:hover {
        border-color: #3498db;
      }

      .menu-title {
        color: #ecf0f1;
      }

      .menu-description {
        color: #bdc3c7;
      }

      .subtitle {
        color: #bdc3c7;
      }

      h1 span {
        color: #95a5a6 !important;
      }

      .footer {
        color: #95a5a6;
        border-top-color: rgba(255, 255, 255, 0.1);
      }
    }

    /* æ›´æ–°ç¢ºèªãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #updateCheckBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }

    #updateCheckBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* ç”»åƒä¸€æ‹¬DLãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #imageBulkDownloadBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
    }

    #imageBulkDownloadBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
    @media (prefers-color-scheme: dark) {
      #imageDownloadModal > div > div {
        background: #34495e !important;
        color: #ecf0f1 !important;
        border: 1px solid #2c3e50 !important;
      }

      #imageDownloadModal h3 {
        color: #ecf0f1 !important;
      }

      #imageDownloadModal > div > div > div:nth-child(2) {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }

      #imageDownloadModal > div > div > div:nth-child(3) {
        background: #f39c12 !important;
        border: 1px solid #e67e22 !important;
        color: #2c3e50 !important;
      }

      #imageDownloadModal #progressText {
        color: #bdc3c7 !important;
      }

      #imageDownloadModal #downloadProgress {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ <br>ç®¡ç†ãƒ„ãƒ¼ãƒ«
      <span style="font-size: 0.4em; color: #999; display: block; margin-top: 5px; font-weight: normal;" id="versionDisplay">[v4.11.3]</span>
    </h1>

    <div class="menu-grid">
      <div class="menu-card" onclick="safeNavigate('card_list.html')" style="cursor: pointer;">
        <span class="menu-icon">ğŸƒ</span>
        <div class="menu-title">ã‚«ãƒ¼ãƒ‰ä¸€è¦§</div>
        <div class="menu-description">
          å…¨ã‚«ãƒ¼ãƒ‰ã®ä¸€è¦§è¡¨ç¤ºãƒ»æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã€‚æ‰€æŒçŠ¶æ³ã®ç®¡ç†ã‚„CSVã§ã®ãƒ‡ãƒ¼ã‚¿ç®¡ç†ãŒå¯èƒ½ã§ã™ã€‚
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('binder_collection.html')" style="cursor: pointer;">
        <span class="menu-icon">ğŸ“š</span>
        <div class="menu-title">ãƒã‚¤ãƒ³ãƒ€ãƒ¼ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³</div>
        <div class="menu-description">
          è¤‡æ•°ã®ãƒã‚¤ãƒ³ãƒ€ãƒ¼ã‚’ç®¡ç†ã€‚ãŠæ°—ã«å…¥ã‚Šã®è¡¨ç´™ç”»åƒã‚’è¨­å®šã—ã¦ã€ãƒ†ãƒ¼ãƒåˆ¥ã«ã‚«ãƒ¼ãƒ‰ã‚’ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ãã¾ã™ã€‚
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('holoca_skill_page.html')" style="cursor: pointer;">
        <span class="menu-icon">ğŸ—‚ï¸</span>
        <div class="menu-title">ã‚«ãƒ¼ãƒ‰è©³ç´°æ¤œç´¢</div>
        <div class="menu-description">
          è©³ç´°ãªæ¡ä»¶ã§ã‚«ãƒ¼ãƒ‰ã‚’æ¤œç´¢ã€‚ã‚¹ã‚­ãƒ«ãƒ»èƒ½åŠ›ãƒ»ã‚³ã‚¹ãƒˆãªã©æ§˜ã€…ãªæ¡ä»¶ã§çµã‚Šè¾¼ã‚ã¾ã™ã€‚
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('deck_builder.html')" style="cursor: pointer;">
        <span class="menu-icon">âš”ï¸</span>
        <div class="menu-title">ãƒ‡ãƒƒã‚­ä½œæˆ</div>
        <div class="menu-description">
          æˆ¦ç•¥çš„ãªãƒ‡ãƒƒã‚­ã‚’æ§‹ç¯‰ã€‚ã‚«ãƒ¼ãƒ‰ã®çµ„ã¿åˆã‚ã›ã‚’è€ƒãˆãªãŒã‚‰æœ€é©ãªãƒ‡ãƒƒã‚­ã‚’ä½œæˆã§ãã¾ã™ã€‚
        </div>
      </div>
    </div>

    <!-- æ›´æ–°ç¢ºèªãƒœã‚¿ãƒ³ -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="updateCheckBtn" onclick="checkForUpdates()" style="
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        ğŸ”„ æ›´æ–°ç¢ºèª
      </button>
      <!-- ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã®ã¿ç”»åƒä¸€æ‹¬DLãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º -->
      <button onclick="showImageDownloadDialog()" id="imageBulkDownloadBtn" class="mobile-only" style="
        background: linear-gradient(45deg, #007bff, #0056b3);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        ğŸ“¥ ç”»åƒä¸€æ‹¬DL
      </button>
      <div id="updateStatus" style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.3; max-width: 400px; white-space: pre-line;"></div>
    </div>

    <div class="footer">
      <p>Â© 2025 ikachan-desuyo - Hololive Card Game Management Tool</p>
      <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯éå…¬å¼ã®ãƒ•ã‚¡ãƒ³ãƒ¡ã‚¤ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã™</p>
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 0.85em; color: #888; line-height: 1.4;">
        <p><strong>æ¨©åˆ©è¡¨è¨˜ãƒ»å…è²¬äº‹é …</strong></p>
        <p>ã€Œãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã€ã€Œhololiveã€ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ã®å•†æ¨™ã§ã™ã€‚</p>
        <p>ã€Œãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã‚ªãƒ•ã‚£ã‚·ãƒ£ãƒ«ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ ã€ã¯æ ªå¼ä¼šç¤¾ãƒ–ã‚·ãƒ­ãƒ¼ãƒ‰ã®å•†æ¨™ã§ã™ã€‚</p>
        <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ãƒ»æ ªå¼ä¼šç¤¾ãƒ–ã‚·ãƒ­ãƒ¼ãƒ‰ã¨ã¯ç„¡é–¢ä¿‚ã®éå…¬å¼ãƒ•ã‚¡ãƒ³ãƒ¡ã‚¤ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
        <p>ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®è‘—ä½œæ¨©ã¯å„æ¨©åˆ©è€…ã«å¸°å±ã—ã¾ã™ã€‚</p>
        <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã«ã‚ˆã‚Šç”Ÿã˜ãŸæå®³ã«ã¤ã„ã¦ã€ä½œæˆè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
      </div>
      <p id="offline-status" style="font-size: 0.8em; margin-top: 10px;"></p>
    </div>
  </div>

  <!-- ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚° -->
  <div id="imageDownloadModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:2000; backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);">
    <div style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
      <div style="background:white; padding:30px; border-radius:10px; max-width:500px; width:90%; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3); animation: modalSlideIn 0.3s ease-out;">
        <h3 style="margin-top:0; color:#333;">ğŸ“¥ ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h3>
        <div style="margin:20px 0; padding:15px; background:#f5f5f5; border-radius:5px; text-align:left;">
          <p style="margin:5px 0;"><strong>å¯¾è±¡ç”»åƒæ•°:</strong> <span id="totalImageCount">-</span> æš</p>
          <p style="margin:5px 0;"><strong>æ¨å®šã‚µã‚¤ã‚º:</strong> <span id="estimatedSize">è¨ˆç®—ä¸­...</span></p>
          <p style="margin:5px 0;"><strong>ç¾åœ¨ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥:</strong> <span id="currentCacheInfo">ç¢ºèªä¸­...</span></p>
          <p style="margin:5px 0; font-size:0.9em; color:#666;">â€» 1æšã‚ãŸã‚Šç´„150-200KBã§è¨ˆç®—</p>
        </div>
        <div style="margin:15px 0; padding:10px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:5px; font-size:0.9em; color:#856404;">
          <strong>âš ï¸ æ³¨æ„äº‹é …</strong><br>
          â€¢ ã‚«ãƒ¼ãƒ‰ä¸€è¦§ãƒšãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ©ç”¨ã—ã¦ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™<br>
          â€¢ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«ã¯æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™<br>
          â€¢ ãƒ¢ãƒã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿é€šä¿¡ã®å ´åˆã€é€šä¿¡é‡ã«ã”æ³¨æ„ãã ã•ã„<br>
          â€¢ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã¯ãƒšãƒ¼ã‚¸ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„
        </div>
        <div id="downloadProgress" style="display:none; margin:15px 0;">
          <div style="background:#e9ecef; border-radius:10px; height:20px; overflow:hidden;">
            <div id="progressBar" style="background:linear-gradient(90deg, #007bff 0%, #28a745 100%); height:100%; width:0%; transition:width 0.3s;"></div>
          </div>
          <p id="progressText" style="margin:10px 0; font-size:0.9em; color:#666; white-space:pre-line;">æº–å‚™ä¸­...</p>
        </div>
        <div style="margin-top:20px;">
          <button onclick="startImageDownload()" id="startDownloadBtn" style="background:#007bff; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px; transition: all 0.3s ease;">ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹</button>
          <button onclick="clearImageCache()" id="clearCacheBtn" style="background:#dc3545; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px;">ğŸ—‘ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‰Šé™¤</button>
          <button onclick="hideImageDownloadDialog()" id="cancelDownloadBtn" style="background:#6c757d; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; font-size:16px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // âœ… Service Worker ã¨ã®é€šä¿¡æ©Ÿèƒ½
    async function sendMessageToSW(type, data = null) {
      if (!navigator.serviceWorker.controller) return null;

      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };

        navigator.serviceWorker.controller.postMessage(
          { type, data },
          [messageChannel.port2]
        );
      });
    }

    // âœ… ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
    async function getVersionInfo() {
      return await sendMessageToSW('GET_VERSION_INFO');
    }

    // âœ… æ›´æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
    async function getUpdateMessage() {
      return await sendMessageToSW('GET_UPDATE_MESSAGE');
    }

    // âœ… å¤ã„ãƒšãƒ¼ã‚¸ã‚’ãƒã‚§ãƒƒã‚¯
    async function checkOutdatedPages() {
      return await sendMessageToSW('CHECK_OUTDATED_PAGES');
    }

    // Service Worker registration with centralized version management
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', {
          updateViaCache: 'none' // ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ï¼šã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ã‚ãšå¸¸ã«æœ€æ–°ã‚’ãƒã‚§ãƒƒã‚¯
        })
          .then((registration) => {
            console.log('SW registered: ', registration);

            // ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ï¼šå³åº§ã«æ›´æ–°ãƒã‚§ãƒƒã‚¯
            registration.update();

            // âœ… æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã§æ›´æ–°ç¢ºèª
            const checkForUpdates = async () => {
              try {
                // Service Worker ãŒæº–å‚™ã§ãã‚‹ã¾ã§å¾…æ©Ÿ
                if (!navigator.serviceWorker.controller) {
                  setTimeout(checkForUpdates, 1000);
                  return;
                }

                const updateMessage = await getUpdateMessage();
                if (!updateMessage) return;

                if (confirm(updateMessage.data.message)) {
                  // å…¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å¾Œã«ãƒªãƒ­ãƒ¼ãƒ‰
                  const cacheNames = await caches.keys();
                  await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                  window.location.href = window.location.href + '?v=' + Date.now();
                }
              } catch (error) {
                console.error('Version check error:', error);
              }
            };

            // Check for waiting service worker with new system
            if (registration.waiting) {
              console.log('SW update available');
              setTimeout(checkForUpdates, 500);
            }

            // Listen for updates with new system
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    setTimeout(checkForUpdates, 500);
                  }
                });
              }
            });

            // Listen for controller change
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              window.location.reload();
            });
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    // ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ï¼šå®šæœŸçš„ãªæ›´æ–°ãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†é–“éš”ï¼‰
    if ('serviceWorker' in navigator && /Mobi|Android/i.test(navigator.userAgent)) {
      setInterval(async () => {
        try {
          const registration = await navigator.serviceWorker.getRegistration();
          if (registration) {
            await registration.update();
            console.log('Mobile: Periodic update check completed');
          }
        } catch (error) {
          console.log('Mobile: Periodic update check failed:', error);
        }
      }, 5 * 60 * 1000); // 5åˆ†é–“éš”
    }

    // Online/Offline status
    function updateOnlineStatus() {
      const statusElement = document.getElementById('offline-status');
      if (navigator.onLine) {
        statusElement.textContent = 'ğŸŸ¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ - æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­';
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.textContent = 'ğŸ”´ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ä¸­';
        statusElement.style.color = '#F44336';
      }
    }

    // Update status on page load and network changes
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    window.addEventListener('load', updateOnlineStatus);

    // Manual update check function
    let serviceWorkerRegistration = null;

    // Store registration for manual update checks
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            serviceWorkerRegistration = registration;
            console.log('SW registered: ', registration);
            // ... existing code above
          });
      });
    }

    async function checkForUpdates() {
      const statusEl = document.getElementById('updateStatus');
      const btnEl = document.getElementById('updateCheckBtn');

      if (!navigator.onLine) {
        statusEl.textContent = 'âš ï¸ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã§ã¯æ›´æ–°ç¢ºèªã§ãã¾ã›ã‚“';
        statusEl.style.color = '#ff9800';
        return;
      }

      try {
        btnEl.disabled = true;
        btnEl.textContent = 'ğŸ”„ ç¢ºèªä¸­...';
        statusEl.textContent = 'ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’ç¢ºèªä¸­...';
        statusEl.style.color = '#2196f3';

        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          const messageChannel = new MessageChannel();

          // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ10ç§’ï¼‰
          const timeout = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Service Worker timeout')), 10000)
          );

          // Service Workerã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…æ©Ÿ
          const checkPromise = new Promise((resolve, reject) => {
            messageChannel.port1.onmessage = (event) => {
              if (event.data.type === 'VERSION_MISMATCH_RESPONSE') {
                resolve(event.data.data);
              } else if (event.data.type === 'VERSION_MISMATCH_ERROR') {
                reject(new Error(event.data.error));
              }
            };
          });

          // è©³ç´°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯è¦æ±‚ã‚’é€ä¿¡
          navigator.serviceWorker.controller.postMessage(
            { type: 'CHECK_VERSION_MISMATCH' },
            [messageChannel.port2]
          );

          // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
          const versionCheckResult = await Promise.race([checkPromise, timeout]);

          if (versionCheckResult.hasUpdates) {
            // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸ä¸€è‡´ã®è©³ç´°æƒ…å ±ã‚’ç”Ÿæˆ
            let detailMessage = 'ğŸš€ ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ä¸ä¸€è‡´ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ:\n\n';
            detailMessage += `ğŸ“Š ã‚¢ãƒ—ãƒªãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${versionCheckResult.currentAppVersion}\n`;
            detailMessage += `ğŸ• ãƒã‚§ãƒƒã‚¯æ™‚åˆ»: ${new Date(versionCheckResult.timestamp).toLocaleString('ja-JP')}\n\n`;

            versionCheckResult.outdatedPages.forEach(pageInfo => {
              detailMessage += `ğŸ“„ ${pageInfo.page}:\n`;
              detailMessage += `  â”£ æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.expectedVersion}\n`;
              detailMessage += `  â”£ å®Ÿéš›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.actualVersion || 'ä¸æ˜'}\n`;
              detailMessage += `  â”£ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.cachedVersion || 'ãªã—'}\n`;

              // ãƒŸã‚¹ãƒãƒƒãƒã®ç†ç”±ã‚’æ—¥æœ¬èªã§èª¬æ˜
              let reasonText = '';
              switch(pageInfo.reason) {
                case 'expected_vs_actual_mismatch':
                  reasonText = 'æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
                  break;
                case 'actual_vs_cached_mismatch':
                  reasonText = 'å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
                  break;
                case 'actual_version_not_found':
                  reasonText = 'å®Ÿéš›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                  break;
                case 'no_cached_version':
                  reasonText = 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“';
                  break;
                default:
                  reasonText = pageInfo.reason;
              }
              detailMessage += `  â”— ç†ç”±: ${reasonText}\n\n`;
            });

            statusEl.innerHTML = `ğŸš€ æ›´æ–°ãŒåˆ©ç”¨å¯èƒ½ã§ã™ (${versionCheckResult.outdatedPages.length}ãƒšãƒ¼ã‚¸)<br><small>è©³ç´°æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„</small>`;
            statusEl.style.color = '#4caf50';
            console.log('Version check details:', versionCheckResult);

            setTimeout(() => {
              if (confirm(detailMessage + 'ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸ä¸€è‡´ã®ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã‹ï¼Ÿ')) {
                statusEl.innerHTML = `âš¡ æ›´æ–°ä¸­...<br><small>å¯¾è±¡ãƒšãƒ¼ã‚¸ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ä¸­</small>`;
                statusEl.style.color = '#ff9800';

                // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸ä¸€è‡´ã®ãƒšãƒ¼ã‚¸ã®ã¿ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã—ãŸæ›´æ–°å‡¦ç†
                console.log('Starting targeted cache clear and update for outdated pages...');

                // Service Workerã«å¼·åˆ¶æ›´æ–°ã‚’è¦æ±‚ï¼ˆå¯¾è±¡ãƒšãƒ¼ã‚¸ã®ã¿ï¼‰
                if (navigator.serviceWorker.controller) {
                  navigator.serviceWorker.controller.postMessage({
                    type: 'FORCE_UPDATE',
                    outdatedPages: versionCheckResult.outdatedPages.map(p => p.page)
                  });
                }

                // å¯¾è±¡ãƒšãƒ¼ã‚¸ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ + å¿…è¦æœ€å°é™ã®å…¨ä½“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
                if ('caches' in window) {
                  caches.keys().then(cacheNames => {
                    return Promise.all(cacheNames.map(cacheName => {
                      console.log('Deleting cache for outdated pages:', cacheName);
                      return caches.delete(cacheName);
                    }));
                  }).then(() => {
                    console.log('Caches cleared for outdated pages');
                    statusEl.innerHTML = `ğŸ”„ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èª­ã¿è¾¼ã¿ä¸­...<br><small>æ›´æ–°ã•ã‚ŒãŸãƒšãƒ¼ã‚¸ã‚’åæ˜ ã—ã¾ã™</small>`;
                    // Service Workerã®æ›´æ–°ã‚’å¾…ã¤
                    return new Promise(resolve => setTimeout(resolve, 1000));
                  }).then(() => {
                    // å¯¾è±¡ãƒšãƒ¼ã‚¸ã®æ›´æ–°ã‚’åæ˜ ã™ã‚‹ãŸã‚ã®ãƒªãƒ­ãƒ¼ãƒ‰
                    console.log('Performing targeted reload for updated pages...');
                    if (window.location.reload) {
                      window.location.reload(true); // å¼·åˆ¶ãƒªãƒ­ãƒ¼ãƒ‰
                    } else {
                      window.location.href = window.location.href + '?t=' + Date.now();
                    }
                  }).catch(error => {
                    console.error('Targeted cache clear failed, forcing reload anyway:', error);
                    window.location.href = window.location.href + '?t=' + Date.now();
                  });
                } else {
                  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥APIãŒä½¿ãˆãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                  window.location.href = window.location.href + '?t=' + Date.now();
                }
              } else {
                // ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã¯å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
                statusEl.innerHTML = `â„¹ï¸ æ›´æ–°ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ<br><small>å¿…è¦ãªæ™‚ã«å†åº¦ç¢ºèªã—ã¦ãã ã•ã„</small>`;
                statusEl.style.color = '#2196f3';
              }
            }, 2000);
          } else {
            // æœ€æ–°ã®å ´åˆã€æ¯”è¼ƒã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’è©³ç´°è¡¨ç¤º
            let versionDetails = `âœ… æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ v${versionCheckResult.currentAppVersion}<br>`;
            versionDetails += `<small>ğŸ“Š å„ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±:<br><br>`;

            if (versionCheckResult.allPages && versionCheckResult.allPages.length > 0) {
              versionCheckResult.allPages.forEach(pageInfo => {
                const pageName = pageInfo.page.replace('.html', '');
                const expectedV = pageInfo.expectedVersion;
                const actualV = pageInfo.actualVersion;
                const status = expectedV === actualV ? 'âœ…' : 'âš ï¸';

                versionDetails += `${status} ${pageName}<br>`;
                versionDetails += `&nbsp;&nbsp;â”œ æœ€æ–°: v${expectedV}<br>`;
                versionDetails += `&nbsp;&nbsp;â”” ç¾åœ¨: v${actualV}<br><br>`;
              });
            } else {
              versionDetails += `å…¨ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒæœ€æ–°ã§ã™`;
            }
            versionDetails += `</small>`;

            statusEl.innerHTML = versionDetails;
            statusEl.style.color = '#4caf50';
            setTimeout(() => {
              statusEl.textContent = '';
            }, 7000); // è¡¨ç¤ºæ™‚é–“ã‚’å»¶é•·
          }
        } else {
          statusEl.textContent = 'âš ï¸ Service Worker ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“';
          statusEl.style.color = '#ff9800';
        }

      } catch (error) {
        console.error('Update check failed:', error);
        statusEl.textContent = 'âŒ æ›´æ–°ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message;
        statusEl.style.color = '#f44336';
      } finally {
        btnEl.disabled = false;
        btnEl.textContent = 'ğŸ”„ æ›´æ–°ç¢ºèª';
      }
    }

    // ã‚»ãƒ¼ãƒ•ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰
    function safeNavigate(url) {
      console.log('Attempting to navigate to:', url);
      
      // offline-utils.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (typeof window.navigateToPage === 'function') {
        console.log('Using offline-aware navigation');
        window.navigateToPage(url);
      } else {
        console.log('offline-utils.js not loaded, using fallback navigation');
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        if (navigator.onLine) {
          window.location.href = url;
        } else {
          // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã®ç°¡æ˜“ãƒã‚§ãƒƒã‚¯
          if (confirm('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã§ã™ã€‚ã“ã®ãƒšãƒ¼ã‚¸ãŒåˆ©ç”¨ã§ããªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚\nç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ')) {
            window.location.href = url;
          }
        }
      }
    }

    // ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
    async function showImageDownloadDialog() {
      console.log('showImageDownloadDialog called');
      
      // ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã®ã¿è¡¨ç¤ºï¼ˆã‚ˆã‚Šå³å¯†ãªåˆ¤å®šï¼‰
      const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      console.log('isMobile check:', isMobile, 'window.innerWidth:', window.innerWidth);
      
      if (!isMobile) {
        console.log('Image bulk download is available only on mobile devices');
        alert('ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¯ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™ã€‚');
        return;
      }
      
      if (imageDownloadInProgress) {
        alert('ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Ÿè¡Œä¸­ã§ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚');
        return;
      }

      console.log('Current cards array length:', cards.length);
      
      // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
      if (cards.length === 0) {
        console.log('Loading card data...');
        const loadedCards = await loadCardData();
        if (loadedCards.length === 0) {
          console.log('Failed to load card data');
          return; // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—
        }
      }

      const modal = document.getElementById('imageDownloadModal');
      const totalImageCountEl = document.getElementById('totalImageCount');
      const estimatedSizeEl = document.getElementById('estimatedSize');
      const currentCacheInfoEl = document.getElementById('currentCacheInfo');
      const startBtn = document.getElementById('startDownloadBtn');
      
      // ç”»åƒæ•°ã‚’è¨ˆç®—
      const imageUrls = extractImageUrls();
      const totalCount = imageUrls.length;
      
      console.log(`Found ${totalCount} images to download`);
      
      if (totalCount === 0) {
        alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯¾è±¡ã®ç”»åƒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        return;
      }
      
      // æ¨å®šã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆ1æšã‚ãŸã‚Š150-200KBã§è¨ˆç®—ï¼‰
      const avgSizeKB = 175; // å¹³å‡ã‚µã‚¤ã‚º
      const estimatedSizeMB = Math.round((totalCount * avgSizeKB) / 1024 * 10) / 10;
      
      totalImageCountEl.textContent = totalCount.toLocaleString();
      estimatedSizeEl.textContent = `ç´„ ${estimatedSizeMB.toLocaleString()} MB`;
      
      // è©³ç´°ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ³ã‚’éåŒæœŸã§å–å¾—
      currentCacheInfoEl.textContent = 'ç¢ºèªä¸­...';
      startBtn.disabled = true;
      startBtn.textContent = 'ç¢ºèªä¸­...';
      
      checkCacheStatus().then(cacheStatus => {
        if (cacheStatus.cached === cacheStatus.total && cacheStatus.total > 0) {
          // å…¨ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿
          currentCacheInfoEl.innerHTML = `âœ… <strong>å…¨ç”»åƒã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿</strong> (${cacheStatus.cached}/${cacheStatus.total}æš)`;
          startBtn.disabled = true;
          startBtn.textContent = 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿';
          startBtn.style.background = '#28a745';
        } else if (cacheStatus.cached > 0) {
          // ä¸€éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿
          currentCacheInfoEl.innerHTML = `âš ï¸ <strong>ä¸€éƒ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿</strong> (${cacheStatus.cached}/${cacheStatus.total}æš)<br>æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥: ${cacheStatus.uncached}æš`;
          startBtn.disabled = false;
          startBtn.textContent = `ğŸ“¥ æ®‹ã‚Š${cacheStatus.uncached}æšã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰`;
          startBtn.style.background = '#ffc107';
          startBtn.style.color = '#212529';
        } else {
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—
          currentCacheInfoEl.innerHTML = `âŒ <strong>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—</strong> (0/${cacheStatus.total}æš)`;
          startBtn.disabled = false;
          startBtn.textContent = 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹';
          startBtn.style.background = '#007bff';
          startBtn.style.color = 'white';
        }
        
        // æ¨å®šãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã‚’æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ†ã®ã¿ã§å†è¨ˆç®—
        if (cacheStatus.uncached > 0) {
          const uncachedSizeMB = Math.round((cacheStatus.uncached * avgSizeKB) / 1024 * 10) / 10;
          estimatedSizeEl.textContent = `ç´„ ${uncachedSizeMB.toLocaleString()} MB (æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ†)`;
        } else if (cacheStatus.cached > 0) {
          estimatedSizeEl.textContent = `ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸è¦`;
        }
        
      }).catch(error => {
        console.error('Cache status error:', error);
        currentCacheInfoEl.textContent = 'âŒ æƒ…å ±å–å¾—å¤±æ•—';
        startBtn.disabled = false;
        startBtn.textContent = 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹';
      });
      
      console.log('Showing modal');
      modal.style.display = 'block';
    }

    // ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’éè¡¨ç¤º
    function hideImageDownloadDialog() {
      const modal = document.getElementById('imageDownloadModal');
      
      if (imageDownloadInProgress) {
        const confirmClose = confirm('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Ÿè¡Œä¸­ã§ã™ã€‚ä¸­æ–­ã—ã¾ã™ã‹ï¼Ÿ');
        if (!confirmClose) return;
        
        // ä¸­æ–­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
        imageDownloadInProgress = false;
        console.log('Image download was cancelled by user');
      }
      
      modal.style.display = 'none';
      
      // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
      resetDownloadProgress();
    }

    // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”»åƒURLã‚’æŠ½å‡º
    function extractImageUrls() {
      const imageUrls = [];
      const seenUrls = new Set();
      
      console.log('Cards array length:', cards.length);
      console.log('Sample card:', cards[0]);
      
      // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã®å ´åˆã€å€¤ã‚’å–å¾—
      const cardArray = Array.isArray(cards) ? cards : Object.values(cards);
      
      for (const card of cardArray) {
        // image_url ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‹ã‚‰ç”»åƒURLã‚’å–å¾—ï¼ˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«åˆã‚ã›ã¦ä¿®æ­£ï¼‰
        const imageUrl = card.image_url || card.image;
        if (imageUrl && !seenUrls.has(imageUrl)) {
          imageUrls.push(imageUrl);
          seenUrls.add(imageUrl);
        }
      }
      
      console.log(`Extracted ${imageUrls.length} unique image URLs`);
      console.log('Sample image URL:', imageUrls[0]);
      return imageUrls;
    }

    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é€²æ—ã‚’ãƒªã‚»ãƒƒãƒˆ
    function resetDownloadProgress() {
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      progressDiv.style.display = 'none';
      progressBar.style.width = '0%';
      progressText.textContent = 'æº–å‚™ä¸­...';
      startBtn.disabled = false;
      startBtn.textContent = 'ğŸ“¥ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹';
      cancelBtn.textContent = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
    }

    // ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é–‹å§‹ï¼ˆcard_list.jsã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç§»æ¤ï¼‰
    async function startImageDownload() {
      if (imageDownloadInProgress) return;
      
      imageDownloadInProgress = true;
      
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      // UIã‚’æ›´æ–°
      progressDiv.style.display = 'block';
      startBtn.disabled = true;
      startBtn.textContent = 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­...';
      cancelBtn.textContent = 'ä¸­æ–­';
      
      try {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã€æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ç”»åƒã®ã¿ã‚’å¯¾è±¡ã«ã™ã‚‹
        progressText.textContent = 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ³ã‚’ç¢ºèªä¸­...';
        const cacheStatus = await checkCacheStatus();
        
        if (cacheStatus.uncached === 0) {
          // å…¨ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿
          progressText.textContent = 'âœ… å…¨ã¦ã®ç”»åƒã¯æ—¢ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ã¾ã™';
          startBtn.textContent = 'âœ… å®Œäº†';
          cancelBtn.textContent = 'é–‰ã˜ã‚‹';
          alert('å…¨ã¦ã®ç”»åƒã¯æ—¢ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
          return;
        }
        
        const imageUrls = cacheStatus.uncachedUrls; // æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ç”»åƒã®ã¿
        const totalCount = imageUrls.length;
        let successCount = 0;
        let failureCount = 0;
        
        console.log(`Starting download of ${totalCount} uncached images`);
        
        progressText.textContent = `æœªã‚­ãƒ£ãƒƒã‚·ãƒ¥ç”»åƒã‚’äº‹å‰èª­ã¿è¾¼ã¿ä¸­... (${totalCount}æš)`;
        
        // ãƒãƒƒãƒã‚µã‚¤ã‚ºï¼ˆåŒæ™‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ•°ï¼‰
        const batchSize = 3; // ãƒãƒƒãƒã‚µã‚¤ã‚ºã‚’å°ã•ãã—ã¦å®‰å®šæ€§å‘ä¸Š
        
        for (let i = 0; i < imageUrls.length; i += batchSize) {
          if (!imageDownloadInProgress) {
            console.log('Download was cancelled by user');
            break; // ä¸­æ–­ã•ã‚ŒãŸå ´åˆ
          }
          
          const batch = imageUrls.slice(i, i + batchSize);
          console.log(`Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(imageUrls.length/batchSize)}`);
          
          const batchPromises = batch.map(async (url) => {
            return new Promise(async (resolve) => {
              try {
                const timeout = setTimeout(() => {
                  console.warn(`Timeout for: ${url}`);
                  resolve({ success: false, url, error: 'Timeout' });
                }, 15000); // 15ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                
                // Service WorkerãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜ã™ã‚‹ã‚ˆã†ã«fetchã‚’å®Ÿè¡Œ
                const response = await fetch(url);
                
                clearTimeout(timeout);
                
                // ãƒ¬ã‚¹ãƒãƒ³ã‚¹çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                if (response.ok || response.type === 'opaque') {
                  console.log(`Successfully fetched: ${url} (status: ${response.status || 'opaque'})`);
                  resolve({ success: true, url, cached: true });
                } else {
                  console.warn(`Failed to fetch: ${url} - Status: ${response.status}`);
                  resolve({ success: false, url, error: `HTTP ${response.status}` });
                }
                
              } catch (error) {
                console.warn(`Fetch failed for: ${url} - ${error.message}`);
                
                // fetchå¤±æ•—ã®å ´åˆã€Imageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                try {
                  const img = new Image();
                  const imgTimeout = setTimeout(() => {
                    resolve({ success: false, url, error: 'Image load timeout' });
                  }, 10000);
                  
                  img.onload = () => {
                    clearTimeout(imgTimeout);
                    console.log(`Image fallback succeeded for: ${url}`);
                    resolve({ success: true, url, cached: false });
                  };
                  
                  img.onerror = () => {
                    clearTimeout(imgTimeout);
                    resolve({ success: false, url, error: 'Image load failed' });
                  };
                  
                  img.src = url;
                } catch (imgError) {
                  resolve({ success: false, url, error: `Both fetch and image failed: ${error.message}` });
                }
              }
            });
          });
          
          // ãƒãƒƒãƒå®Ÿè¡Œ
          const batchResults = await Promise.all(batchPromises);
          
          // çµæœã‚’é›†è¨ˆ
          batchResults.forEach(result => {
            if (result.success) {
              successCount++;
            } else {
              failureCount++;
              console.warn(`Failed: ${result.url} - ${result.error}`);
            }
          });
          
          // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°
          const progress = Math.round((successCount + failureCount) / totalCount * 100);
          progressBar.style.width = `${progress}%`;
          
          // å…¨ä½“ã®é€²æ—æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆæ—¢ã‚­ãƒ£ãƒƒã‚·ãƒ¥ + æ–°è¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼‰
          const totalCachedNow = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `${successCount + failureCount} / ${totalCount} å®Œäº† (æˆåŠŸ: ${successCount}, å¤±æ•—: ${failureCount})\nå…¨ä½“: ${totalCachedNow}/${grandTotal}æšãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿`;
          
          // å°‘ã—å¾…æ©Ÿï¼ˆã‚µãƒ¼ãƒãƒ¼è² è·è»½æ¸›ï¼‰
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        if (imageDownloadInProgress) {
          // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          
          if (failureCount === 0) {
            progressText.textContent = `âœ… æ–°è¦ç”»åƒã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼ (${successCount}æš)\nå…¨ä½“: ${totalCachedFinal}/${grandTotal}æšãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿`;
            alert(`ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼\n\næ–°è¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰: ${successCount}æš\næ—¢å­˜ã‚­ãƒ£ãƒƒã‚·ãƒ¥: ${cacheStatus.cached}æš\nåˆè¨ˆ: ${totalCachedFinal}/${grandTotal}æš\n\nã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã‚‚ç”»åƒãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚`);
          } else {
            progressText.textContent = `âš ï¸ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº† (æˆåŠŸ: ${successCount}æš, å¤±æ•—: ${failureCount}æš)\nå…¨ä½“: ${totalCachedFinal}/${grandTotal}æšãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿`;
            alert(`ç”»åƒä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸã€‚\n\næ–°è¦æˆåŠŸ: ${successCount}æš\nå¤±æ•—: ${failureCount}æš\næ—¢å­˜ã‚­ãƒ£ãƒƒã‚·ãƒ¥: ${cacheStatus.cached}æš\n\næˆåŠŸã—ãŸç”»åƒã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã‚‚è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚`);
          }
          
          startBtn.textContent = 'âœ… å®Œäº†';
          cancelBtn.textContent = 'é–‰ã˜ã‚‹';
        } else {
          // ä¸­æ–­ã•ã‚ŒãŸå ´åˆ
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒä¸­æ–­ã•ã‚Œã¾ã—ãŸ (æˆåŠŸ: ${successCount}æš, å¤±æ•—: ${failureCount}æš)\nå…¨ä½“: ${totalCachedFinal}/${grandTotal}æšãŒã‚­ãƒ£ãƒƒã‚·ãƒ¥æ¸ˆã¿`;
          startBtn.textContent = 'ä¸­æ–­æ¸ˆã¿';
          cancelBtn.textContent = 'é–‰ã˜ã‚‹';
        }
        
      } catch (error) {
        console.error('Image download error:', error);
        progressText.textContent = 'âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
        alert(`ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼š${error.message}`);
        
        startBtn.textContent = 'âŒ ã‚¨ãƒ©ãƒ¼';
        cancelBtn.textContent = 'é–‰ã˜ã‚‹';
      } finally {
        imageDownloadInProgress = false;
        startBtn.disabled = false;
      }
    }

    // ç”»åƒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
    async function clearImageCache() {
      if (!confirm('ç”»åƒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\nå‰Šé™¤å¾Œã¯å†åº¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚')) {
        return;
      }

      const clearBtn = document.getElementById('clearCacheBtn');
      const originalText = clearBtn.textContent;
      
      try {
        clearBtn.disabled = true;
        clearBtn.textContent = 'å‰Šé™¤ä¸­...';
        
        // ã™ã¹ã¦ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å–å¾—
        const cacheNames = await caches.keys();
        console.log('Available caches:', cacheNames);
        
        let deletedCount = 0;
        let totalSize = 0;
        
        // ç”»åƒé–¢é€£ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          const requests = await cache.keys();
          
          for (const request of requests) {
            // ç”»åƒURLã¾ãŸã¯hololive-official-cardgame.comã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤
            if (request.url.includes('hololive-official-cardgame.com') ||
                request.url.includes('.jpg') ||
                request.url.includes('.png') ||
                request.url.includes('.jpeg') ||
                request.url.includes('.webp')) {
              
              const response = await cache.match(request);
              if (response) {
                const clonedResponse = response.clone();
                try {
                  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚µã‚¤ã‚ºã‚’æ¨å®šï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
                  const blob = await clonedResponse.blob();
                  totalSize += blob.size;
                } catch (e) {
                  // ã‚µã‚¤ã‚ºå–å¾—å¤±æ•—ã¯ç„¡è¦–
                }
              }
              
              await cache.delete(request);
              deletedCount++;
              console.log('Deleted cached image:', request.url);
            }
          }
        }
        
        // ã‚µã‚¤ã‚ºã‚’äººé–“ãŒèª­ã‚ã‚‹å½¢å¼ã«å¤‰æ›
        const sizeText = totalSize > 0 ? 
          `ç´„ ${(totalSize / (1024 * 1024)).toFixed(1)} MB` : 
          'ä¸æ˜';
        
        clearBtn.textContent = 'âœ… å‰Šé™¤å®Œäº†';
        
        alert(`ç”»åƒã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤ã—ã¾ã—ãŸï¼\n\nå‰Šé™¤ã—ãŸç”»åƒæ•°: ${deletedCount}æš\nå‰Šé™¤ã—ãŸã‚µã‚¤ã‚º: ${sizeText}\n\næ¬¡å›è¡¨ç¤ºæ™‚ã«ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã™ã€‚`);
        
        // UIã‚’ãƒªã‚»ãƒƒãƒˆ
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
        
      } catch (error) {
        console.error('Cache clear error:', error);
        clearBtn.textContent = 'âŒ ã‚¨ãƒ©ãƒ¼';
        alert(`ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼š${error.message}`);
        
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
      }
    }

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥çŠ¶æ³ã‚’è©³ç´°ãƒã‚§ãƒƒã‚¯
    async function checkCacheStatus() {
      try {
        const imageUrls = extractImageUrls();
        const cacheNames = await caches.keys();
        
        let cachedUrls = new Set();
        let uncachedUrls = [];
        
        // ã™ã¹ã¦ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          
          for (const url of imageUrls) {
            const response = await cache.match(url);
            if (response) {
              cachedUrls.add(url);
            }
          }
        }
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ãªã„URLã‚’ç‰¹å®š
        for (const url of imageUrls) {
          if (!cachedUrls.has(url)) {
            uncachedUrls.push(url);
          }
        }
        
        return {
          total: imageUrls.length,
          cached: cachedUrls.size,
          uncached: uncachedUrls.length,
          cachedUrls: Array.from(cachedUrls),
          uncachedUrls: uncachedUrls
        };
        
      } catch (error) {
        console.error('Cache status check error:', error);
        return {
          total: 0,
          cached: 0,
          uncached: 0,
          cachedUrls: [],
          uncachedUrls: []
        };
      }
    }

    // ç”»åƒä¸€æ‹¬DLæ©Ÿèƒ½ - ã‚«ãƒ¼ãƒ‰ä¸€è¦§ãƒšãƒ¼ã‚¸ã¨é€£æº
    let imageDownloadInProgress = false;
    let cards = []; // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¿æŒ

    // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’å‹•çš„ã«èª­ã¿è¾¼ã¿
    async function loadCardData() {
      try {
        const response = await fetch('json_file/card_data.json');
        if (!response.ok) throw new Error('ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
        const cardData = await response.json();
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã¯é…åˆ—ã«å¤‰æ›
        cards = Array.isArray(cardData) ? cardData : Object.values(cardData);
        console.log(`Loaded ${cards.length} cards for image download`);
        console.log('Sample card:', cards[0]);
        return cards;
      } catch (error) {
        console.error('Card data loading error:', error);
        alert('ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        return [];
      }
    }
  </script>
  <!-- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ç®¡ç† -->
  <script src="js/offline-utils.js"></script>
</body>
</html>
