<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ğŸ“¸ ã‚«ãƒ¼ãƒ‰æ æ¤œå‡ºï¼‹è§’åº¦è£œæ­£</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- âœ… ãƒ­ãƒ¼ã‚«ãƒ«ã® OpenCV.js ã‚’èª­ã¿è¾¼ã¿ -->
  <script defer src="libs/opencv.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 16px;
      background: #f5f5f5;
    }
    canvas {
      border: 1px solid #ccc;
      margin-top: 12px;
      max-width: 100%;
    }
    #loading {
      margin-top: 8px;
      font-size: 14px;
      color: #666;
    }
    #progress-bar {
      width: 100%;
      height: 6px;
      background: #eee;
      overflow: hidden;
      position: relative;
      margin-top: 8px;
    }
    #progress-fill {
      width: 30%;
      height: 100%;
      background: #3b82f6;
      animation: loadAnim 1.2s infinite;
    }
    @keyframes loadAnim {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(300%); }
    }
  </style>
</head>
<body>
  <h2>ğŸ“¸ ã‚«ãƒ¼ãƒ‰æ æ¤œå‡ºï¼‹è§’åº¦è£œæ­£</h2>

  <input type="file" accept="image/*" onchange="processCardImage(event)" />
  <div id="loading">ğŸ” OpenCVèª­ã¿è¾¼ã¿ç¢ºèªä¸­â€¦</div>
  <div id="progress-bar"><div id="progress-fill"></div></div>

  <canvas id="inputCanvas"></canvas>
  <canvas id="croppedCanvas"></canvas>

  <script>
    const inputCanvas = document.getElementById("inputCanvas");
    const croppedCanvas = document.getElementById("croppedCanvas");
    const loading = document.getElementById("loading");
    document.getElementById("progress-bar").style.display = "block";

    // âœ… OpenCV.js èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ›´æ–°
    cv['onRuntimeInitialized'] = () => {
      document.getElementById("progress-bar").style.display = "none";
      document.getElementById("loading").textContent = "âœ… OpenCVèª­ã¿è¾¼ã¿å®Œäº†ï¼ã‚«ãƒ¼ãƒ‰ç”»åƒã‚’é¸æŠã—ã¦ã­";
    };

    function processCardImage(event) {
      const file = event.target.files[0];
      if (!file || typeof cv === "undefined") {
        alert("OpenCV.jsãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚‚ã†å°‘ã—å¾…ã£ã¦ã¿ã¦ãã ã•ã„");
        return;
      }

      const img = new Image();
      img.onload = () => detectAndCropCard(img);
      img.src = URL.createObjectURL(file);
    }

    function detectAndCropCard(img) {
      inputCanvas.width = img.width;
      inputCanvas.height = img.height;
      const ctx = inputCanvas.getContext("2d");
      ctx.drawImage(img, 0, 0);

      const src = cv.imread(inputCanvas);
      const gray = new cv.Mat();
      const blurred = new cv.Mat();
      const edges = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
      cv.Canny(blurred, edges, 50, 150);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let bestContour = null;
      let bestRect = null;
      let maxArea = 0;

      // ğŸ§  ç²¾åº¦è£œæ­£ï¼šå¤§ããªé•·æ–¹å½¢ã ã‘æŠ½å‡º
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if (area < 50000) continue; // å°ã•ã„é ˜åŸŸã¯é™¤å¤–

        const rect = cv.minAreaRect(cnt);
        const w = rect.size.width;
        const h = rect.size.height;
        const aspect = Math.max(w, h) / Math.min(w, h);
        if (aspect > 3.5 || aspect < 1.0) continue; // æ¥µç«¯ãªå½¢çŠ¶ã¯é™¤å¤–

        if (area > maxArea) {
          maxArea = area;
          bestContour = cnt;
          bestRect = rect;
        }
      }

      if (!bestRect) {
        loading.textContent = "âŒ æœ‰åŠ¹ãªã‚«ãƒ¼ãƒ‰æ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ";
        return;
      }

      const angle = bestRect.angle;
      const center = bestRect.center;
      const rotMat = cv.getRotationMatrix2D(center, angle, 1);
      const rotated = new cv.Mat();
      cv.warpAffine(src, rotated, rotMat, new cv.Size(src.cols, src.rows), cv.INTER_LINEAR);

      // âœ‚ æ é ˜åŸŸã‚’æ­£ç¢ºã«åˆ‡ã‚Šå‡ºã—
      const box = cv.RotatedRect.points(bestRect);
      const xs = box.map(pt => pt.x);
      const ys = box.map(pt => pt.y);
      const minX = Math.max(Math.floor(Math.min(...xs)), 0);
      const maxX = Math.min(Math.floor(Math.max(...xs)), rotated.cols);
      const minY = Math.max(Math.floor(Math.min(...ys)), 0);
      const maxY = Math.min(Math.floor(Math.max(...ys)), rotated.rows);
      const rect = new cv.Rect(minX, minY, maxX - minX, maxY - minY);

      const cropped = rotated.roi(rect);
      croppedCanvas.width = rect.width;
      croppedCanvas.height = rect.height;
      cv.imshow(croppedCanvas, cropped);

      loading.textContent = `âœ… æ æ¤œå‡ºãƒ»æ•´åˆ—å®Œäº†ï¼ˆè§’åº¦ ${Math.round(angle)}Â°ï¼ã‚µã‚¤ã‚º ${rect.width}Ã—${rect.height}ï¼‰`;

      // å¾Œå‡¦ç†
      src.delete(); gray.delete(); blurred.delete(); edges.delete();
      contours.delete(); hierarchy.delete(); rotated.delete(); cropped.delete();
    }
  </script>
</body>
</html>