<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ãƒ‡ãƒƒã‚­ä½œæˆ</title>
  <style>
    html, body {
        touch-action: manipulation;
    }

    body {
      font-family: sans-serif;
      margin: 0;
      font-size: 15px;
      padding: 10px;
    }

    h2 {
      margin-right: auto;
    }

    .deck-header {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 16px;
    }

    .deck-controls button,
    .deck-controls select,
    .deck-controls input[type="file"] {
      font-size: 14px;
      padding: 6px 12px;
    }

    .deck-list {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 12px;
      padding-bottom: 10px;
    }

    .deck-box {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      width: 120px;
      text-align: center;
      cursor: pointer;
    }

    .deck-box:hover {
      background: #20262e;
    }

    .deck-box img {
      width: 80px;
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .deck-thumbnail-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .card-thumb {
      position: relative;
      width: 60px;
    }

    .card-thumb img {
      width: 100%;
      border-radius: 4px;
      border: 1px solid #ccc;
      object-fit: cover;
    }

    .count-badge {
      position: absolute;
      bottom: -6px;
      right: -6px;
      background: #007acc;
      color: #fff;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 10px;
    }

    .delete-btn {
      position: absolute;
      top: -6px;
      right: -6px;
      background: #f44336;
      color: #fff;
      font-size: 12px;
      border-radius: 50%;
      padding: 0 5px;
      cursor: pointer;
      line-height: 1;
    }

    .card-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
      gap: 12px;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
      gap: 10px;
    }

    .card-box {
      display: flex;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 1px;
      align-items: center;
      cursor: pointer;
      flex-direction: column;
    }

    .card-box:hover {
      background: #20262e;
    }

    .card-info {
      flex-grow: 1;
      font-size: 9px;
      line-height: 1.5;
    }

    .card-box img {
      width: 100%;
      border-radius: 4px;
      margin-right: 4px;
      object-fit: cover;
    }

    .filter-group {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .chip {
      padding: 6px 12px;
      border: 1px solid #aaa;
      border-radius: 16px;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
    }

    .chip:hover {
      background: #ddd;
    }

    .chip.selected {
      background: #0095ff;
      color: #fff;
      border-color: #007acc;
    }

    .chip.all-chip {
      font-weight: bold;
    }

    .top-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 10px 0;
    }

    body.dark {
      background-color: #222;
      color: #eee;
    }

    body.dark select,
    body.dark button,
    body.dark input {
      background-color: #222;
      color: #eee;
      border-color: #555;
    }

    body.dark .chip {
      background-color: #333;
      color: #ddd;
      border-color: #555;
    }

    body.dark .chip.selected {
      background-color: #007acc;
      color: #fff;
    }

    #cardStats {
      position: sticky;
      top: 0;
      z-index: 12; /* â† é«˜ã‚ã«ã—ã¦é‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
      background-color: #fff;
      padding: 4px 0;
    }

    .top-controls {
      position: sticky;
      z-index: 10;
      top: 28px; /* â† statsã®é«˜ã•åˆ†ãšã‚‰ã™ï¼ˆèª¿æ•´OKï¼‰ */
      background-color: #fff;
      padding: 4px 0;
    }

    #filtersWrapper {
      position: sticky;
      z-index: 10;
      top: 55px; /* â† statsã®é«˜ã•åˆ†ãšã‚‰ã™ï¼ˆèª¿æ•´OKï¼‰ */
      background-color: #fff;
      padding: 4px 0;
    }

    #productFilter {
      max-width: 500px;
      font-size: 13px;
    }

    body.dark #cardStats,
    body.dark .top-controls,
    body.dark #filtersWrapper {
      background-color: #222;
    }

    .mobile-layout .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
      gap: 10px;
    }

    .mobile-layout .card-box {
      display: flex;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 1px;
      align-items: center;
      cursor: pointer;
      flex-direction: column;
    }

    .mobile-layout .card-box img {
      width: 80px;
      border-radius: 4px;
      margin-right: 4px;
      object-fit: cover;
    }

    .mobile-layout .card-info {
      flex-grow: 1;
      font-size: 9px;
      line-height: 1.5;
    }

    .mobile-layout .deck-list {
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 12px;
      padding-bottom: 10px;
    }

    .mobile-layout .deck-box {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 5px;
      width: 60px;
      text-align: center;
      cursor: pointer;
      font-size: 7px;
    }

    .mobile-layout .deck-box:hover {
      background: #20262e;
    }

    .mobile-layout .deck-box img {
      width: 100%;
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .mobile-layout .deck-thumbnail-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }

    .mobile-layout .card-thumb {
      position: relative;
      width: 40px;
    }

    .mobile-layout .card-thumb img {
      width: 100%;
      border-radius: 4px;
      border: 1px solid #ccc;
      object-fit: cover;
    }

    .mobile-layout .filter-wrapper {
      gap: 6px;
    }

    .mobile-layout .filter-wrapper button {
      font-size: 12px;
      padding: 4px 8px;
      height: auto;
    }

    .mobile-layout #productFilter {
      max-width: 400px;
      font-size: 13px;
    }

    /* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å…¨ä½“ã®æ–‡å­—ã‚µã‚¤ã‚º */
    .mobile-layout .filter-group legend {
      font-size: 13px;
      margin-bottom: 6px;
    }

    /* ãƒãƒƒãƒ—ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚ºï¼ˆpaddingã¨æ–‡å­—ã‚µã‚¤ã‚ºï¼‰ */
    .mobile-layout .chip {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 12px;
    }

    /* ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚µã‚¤ã‚º */
    .mobile-layout select {
      font-size: 13px;
      padding: 4px 6px;
    }

    /* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ ã®ä½™ç™½ãƒ»è§’ä¸¸ */
    .mobile-layout .filter-group {
      padding: 6px;
      border-radius: 4px;
    }

    /* ãƒãƒƒãƒ—ã‚°ãƒ«ãƒ¼ãƒ—é–“ã®éš™é–“ */
    .mobile-layout .chip-group {
      gap: 6px;
    }

  </style>
</head>
<body>
    <div id="deckheader" class="deck-header">
      <button onclick="history.back()">â† å‰ã®ãƒšãƒ¼ã‚¸ã¸</button>
      <h2>ğŸ§  ãƒ‡ãƒƒã‚­ä½œæˆ</h2>
      <div class="top-nav">
        <button onclick="location.href='holoca_skill_page.html'">ğŸ—‚ ã‚«ãƒ¼ãƒ‰è©³ç´°æ¤œç´¢</button>
      </div>
      <div class="deck-controls">
        <button onclick="toggleDarkMode()" style="margin-bottom: 10px;">
            ğŸŒ— ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        </button>
        <button onclick="createDeck()">â• ãƒ‡ãƒƒã‚­ä½œæˆ</button>
        <select id="deckSelector" onchange="switchDeck()">
          <option value="">ğŸ“‚ ãƒ‡ãƒƒã‚­é¸æŠ</option>
        </select>
        <button onclick="deleteDeck()">ğŸ—‘ï¸ å‰Šé™¤</button>
        <button onclick="exportDecks()">ğŸ’¾ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
        <label>
          ğŸ“ ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
          <input type="file" id="importFile" onchange="importDecks()" />
        </label>
      </div>
    </div>
  
    <!-- âœ… è¦–è¦šçš„ãƒ‡ãƒƒã‚­ä¸€è¦§ -->
    <div id="deckList" class="deck-list"></div>
  
    <!-- âœ… é¸æŠä¸­ãƒ‡ãƒƒã‚­ã®ä¸­èº«ï¼ˆã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤ºãƒ»æšæ•°ãƒ»å‰Šé™¤ï¼‰ -->
    <div id="deckView">
      <h3>ç¾åœ¨ã®ãƒ‡ãƒƒã‚­: <span id="currentDeckName">æœªé¸æŠ</span></h3>
      <div id="deckCardList" class="deck-thumbnail-grid"></div>
    </div>

    <div id="cardStats" style="margin: 6px 0; font-weight: bold;"></div>
  
    <!-- âœ… ã‚«ãƒ¼ãƒ‰é¸æŠãƒ“ãƒ¥ãƒ¼ï¼šãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼‹ç°¡æ˜“è¡¨ç¤ºï¼ˆé¸æŠæ™‚ã®ã¿è¡¨ç¤ºï¼‰ -->
    <div id="cardSelectionArea" style="display:none; margin-top:20px;">
      <h3>ğŸƒ ã‚«ãƒ¼ãƒ‰ä¸€è¦§ï¼ˆãƒ‡ãƒƒã‚­ã«è¿½åŠ ï¼‰</h3>
      <div class="top-controls">
        <input type="text" id="nameSearch" placeholder="æ¤œç´¢" oninput="renderCardSelectionGallery()" />
        <select id="sortMethod" onchange="renderCardSelectionGallery()">
          <option value="release">ç™ºå£²æ—¥é †</option>
          <option value="id">ã‚«ãƒ¼ãƒ‰ç•ªå·é †</option>
          <option value="name">åå‰é †</option>
          <option value="rarity">ãƒ¬ã‚¢ãƒªãƒ†ã‚£é †</option>
        </select>
        <button onclick="toggleFilters()">ğŸ”½ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤ºï¼éè¡¨ç¤º</button>
      </div>
  
      <div id="filtersWrapper" style="display:none;">
        <fieldset class="filter-group">
          <legend>æ‰€æŒçŠ¶æ…‹</legend>
          <div id="ownedStateChipGroup" class="chip-group"></div>
        </fieldset>
        <fieldset class="filter-group">
          <legend>ãƒ¬ã‚¢ãƒªãƒ†ã‚£</legend>
          <div id="rarityFilter" class="chip-group"></div>
        </fieldset>
        <fieldset class="filter-group">
          <legend>è‰²</legend>
          <div id="colorFilter" class="chip-group"></div>
        </fieldset>
        <fieldset class="filter-group">
          <legend>Bloom</legend>
          <div id="bloomFilter" class="chip-group"></div>
        </fieldset>
        <fieldset class="filter-group">
          <legend>ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</legend>
          <div id="cardTypeChipGroup" class="chip-group"></div>
        </fieldset>
        <fieldset class="filter-group">
          <legend>ã‚¿ã‚°</legend>
          <select id="tagFilterSelect" onchange="renderCardSelectionGallery()">
            <option value="">ã‚¿ã‚°ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>
        <fieldset class="filter-group">
          <legend>åéŒ²å•†å“</legend>
          <select id="productFilter" onchange="renderCardSelectionGallery()">
            <option value="">åéŒ²å•†å“ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>
      </div>
  
      <div id="cardGallery" class="card-gallery"></div>
    </div>
    <script>
        let decks = {};
        let currentDeck = null;
        let cards = [];
        let releaseMap = {};

        function normalizeText(text) {
          return text
            .toLowerCase()
            .replace(/[ã-ã‚–]/g, s => String.fromCharCode(s.charCodeAt(0) + 0x60))  // ã²ã‚‰ãŒãªâ†’ã‚«ã‚¿ã‚«ãƒŠå¤‰æ›
            .replace(/[ã‚¡-ãƒ³]/g, s => String.fromCharCode(s.charCodeAt(0) - 0x60)); // ã‚«ã‚¿ã‚«ãƒŠâ†’ã²ã‚‰ãŒãªå¤‰æ›ï¼ˆåŒæ–¹å‘æ€§ï¼‰
        }

        function toggleDarkMode() {
            const isDark = document.body.classList.toggle("dark");
            localStorage.setItem("darkMode", isDark ? "true" : "false");
        }

        function createDeck() {
          const name = prompt("æ–°ã—ã„ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
          if (!name || name.trim() === "") {
            alert("ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            return;
          }
          if (decks[name]) {
            alert("åŒã˜åå‰ã®ãƒ‡ãƒƒã‚­ãŒã™ã§ã«å­˜åœ¨ã—ã¾ã™");
            return;
          }
          decks[name] = [];
          currentDeck = name;
          updateDeckUI();
        }
      
        function switchDeck() {
          const select = document.getElementById("deckSelector");
          currentDeck = select.value;
          updateDeckUI();
        }
      
        function deleteDeck() {
            if (!currentDeck) return;
            if (!confirm(`ã€Œ${currentDeck}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;

            delete decks[currentDeck];
            currentDeck = null;

            // âœ… å‘¼ã³å‡ºã—é †ã‚’ä¿è¨¼
            updateDeckUI();
            renderDeckList();
        }
      
        function addCardToDeck(cardId) {
          if (!currentDeck) {
            alert("å…ˆã«ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„");
            return;
          }
          decks[currentDeck].push(cardId);
          updateDeckUI();
        }
      
        function exportDecks() {
          const blob = new Blob([JSON.stringify(decks, null, 2)], {type: "application/json"});
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "decks.json";
          link.click();
        }
      
        function importDecks() {
          const file = document.getElementById("importFile").files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = e => {
            try {
              decks = JSON.parse(e.target.result);
              currentDeck = Object.keys(decks)[0] ?? null;
              updateDeckUI();
            } catch {
              alert("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
            }
          };
          reader.readAsText(file);
        }
      
        function updateDeckUI() {
          localStorage.setItem("deckData", JSON.stringify(decks));

          const select = document.getElementById("deckSelector");
          select.innerHTML = `<option value="">ğŸ“‚ ãƒ‡ãƒƒã‚­é¸æŠ</option>` +
            Object.keys(decks).map(name =>
              `<option value="${name}" ${name === currentDeck ? "selected" : ""}>${name} (${decks[name].length})</option>`
            ).join("");

          document.getElementById("currentDeckName").textContent = currentDeck || "æœªé¸æŠ";
          const list = document.getElementById("deckCardList");
          list.innerHTML = "";

          if (!currentDeck) {
            document.getElementById("cardSelectionArea").style.display = "none";
            return;
          }

          document.getElementById("cardSelectionArea").style.display = "block";

          // âœ… é¸æŠæšæ•°åˆè¨ˆè¡¨ç¤º
          document.getElementById("cardStats").textContent = `ğŸ§  é¸æŠæšæ•°ï¼š${decks[currentDeck].length}æš`;

          // âœ… ãƒ‡ãƒƒã‚­æ§‹æˆåˆ†é¡ï¼ˆæ¨ã—ãƒ»ã‚¨ãƒ¼ãƒ«ãƒ»ãã®ä»–ï¼‰
          function classifyDeckByType(deckIds) {
            const typeCounts = { oshi: 0, cheer: 0, other: 0 };
            deckIds.forEach(id => {
              const card = cards.find(c => c.id === id);
              if (!card) return;
              if (card.card_type === "æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³") typeCounts.oshi += 1;
              else if (card.card_type === "ã‚¨ãƒ¼ãƒ«") typeCounts.cheer += 1;
              else typeCounts.other += 1;
            });
            return typeCounts;
          }

          const typeCounts = classifyDeckByType(decks[currentDeck]);
          let warning = "";
          if (typeCounts.oshi > 1) warning += `ğŸ’¥ æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³ã¯1æšå¿…è¦ã§ã™\n`;
          if (typeCounts.cheer > 20) warning += `ğŸ’¥ ã‚¨ãƒ¼ãƒ«ã‚«ãƒ¼ãƒ‰ã¯æœ€å¤§20æšã¾ã§ã§ã™\n`;
          if (typeCounts.other > 40) warning += `ğŸ’¥ ãã®ä»–ã‚«ãƒ¼ãƒ‰ã¯æœ€å¤§40æšã¾ã§ã§ã™\n`;
          if (warning) alert(warning);

          // âœ… ãƒ‡ãƒƒã‚­æ§‹æˆã‚’è¡¨ç¤ºï¼ˆä»»æ„ã®ä½ç½®ã« #deckBreakdown ãŒã‚ã‚‹å‰æï¼‰
          const breakdown = document.getElementById("deckBreakdown");
          if (breakdown) {
            breakdown.textContent =
              `ğŸ’– æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³ï¼š${typeCounts.oshi}æšã€€ğŸ“£ ã‚¨ãƒ¼ãƒ«ï¼š${typeCounts.cheer}æšã€€ğŸ´ ãã®ä»–ï¼š${typeCounts.other}æš`;
          }

          const countMap = {};
          decks[currentDeck].forEach(id => {
            countMap[id] = (countMap[id] || 0) + 1;
          });

          Object.entries(countMap).sort().forEach(([cardId, count]) => {
            const wrapper = document.createElement("div");
            wrapper.className = "card-thumb";

            const card = cards.find(c => c.id === cardId);
            const img = document.createElement("img");
            img.src = card?.image ?? `images/${cardId}.png`;
            img.alt = card?.name ?? cardId;
            img.onerror = () => { img.src = "images/placeholder.png"; };
            wrapper.appendChild(img);

            const badge = document.createElement("div");
            badge.className = "count-badge";
            badge.textContent = `Ã—${count}`;
            wrapper.appendChild(badge);

            const del = document.createElement("div");
            del.className = "delete-btn";
            del.textContent = "Ã—";
            del.onclick = () => {
              decks[currentDeck] = decks[currentDeck].filter(id => id !== cardId);
              updateDeckUI();
            };
            wrapper.appendChild(del);

            list.appendChild(wrapper);
          });

          renderDeckList();
          renderCardSelectionGallery();
        }
      
        function renderDeckList() {
          const container = document.getElementById("deckList");
          container.innerHTML = "";

          const deckNames = Object.keys(decks).filter(name => decks[name] && decks[name].length >= 0);
          if (deckNames.length === 0) {
            container.innerHTML = "<div style='color:#666;'>ğŸ“‚ ãƒ‡ãƒƒã‚­ã¯å­˜åœ¨ã—ã¾ã›ã‚“</div>";
            return;
          }

          const cardMap = Object.fromEntries(cards.map(c => [c.id, c]));

          deckNames.forEach(name => {
            const cardIds = decks[name];

            // âœ… æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³ã®ç”»åƒã‚’æ¢ã™
            const oshiCardId = cardIds.find(id => {
              const card = cardMap[id];
              return card?.card_type === "æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³";
            });

            const fallbackId = cardIds[0] ?? "placeholder";
            const imageId = oshiCardId ?? fallbackId;
            const imageUrl = cardMap[imageId]?.image ?? `images/${imageId}.png`;

            const box = document.createElement("div");
            box.className = "deck-box";
            box.onclick = () => {
              currentDeck = name;
              updateDeckUI();
            };
            box.innerHTML = `
              <img src="${imageUrl}" alt="${name}" onerror="this.src='images/placeholder.png'" />
              <div style="font-weight:bold;">${name}</div>
              <div>æšæ•°: ${cardIds.length}</div>
            `;
            container.appendChild(box);
          });
        }
      
        function toggleFilters() {
          const el = document.getElementById("filtersWrapper");
          el.style.display = window.getComputedStyle(el).display === "none" ? "block" : "none";
        }
      
        function toggleChip(btn) {
          const group = btn.parentElement;
          const allBtn = group.querySelector(".all-chip");
          if (allBtn) allBtn.classList.remove("selected");
          btn.classList.toggle("selected");
          renderCardSelectionGallery();
        }
      
        function selectAllChip(allBtn) {
          const group = allBtn.parentElement;
          group.querySelectorAll(".chip").forEach(btn => btn.classList.remove("selected"));
          allBtn.classList.add("selected");
          renderCardSelectionGallery();
        }
      
        function getCheckedFromChips(id) {
          const allSelected = document.querySelector(`#${id} .chip.all-chip.selected`);
          if (allSelected) return [];
          return [...document.querySelectorAll(`#${id} .chip.selected:not(.all-chip)`)].map(btn => btn.dataset.value);
        }
      
        function setupFilterChips() {
          const raritySet = new Set();
          const colorSet = new Set();
          const bloomSet = new Set();
          const productSet = new Set();
          const tagSet = new Set();
          const typePartsSet = new Set();

          cards.forEach(c => {
            raritySet.add(c.rarity);
            colorSet.add(c.color);
            bloomSet.add(c.bloom);
            productSet.add(c.product);
            c.tags?.forEach(tag => tagSet.add(tag));
            const typeParts = c.card_type?.split("ãƒ»") ?? [];
            typeParts.forEach(part => typePartsSet.add(part.trim()));
          });

          function populateChipGroup(id, items, withAll = true) {
            const container = document.getElementById(id);
            container.innerHTML = "";
            if (withAll) {
              const allBtn = document.createElement("button");
              allBtn.textContent = "ã™ã¹ã¦";
              allBtn.className = "chip all-chip selected";
              allBtn.dataset.value = "ALL";
              allBtn.onclick = () => selectAllChip(allBtn);
              container.appendChild(allBtn);
            }
            [...items].sort().forEach(val => {
              const btn = document.createElement("button");
              btn.textContent = val;
              btn.className = "chip";
              btn.dataset.value = val;
              btn.onclick = () => toggleChip(btn);
              container.appendChild(btn);
            });
          }

          function populateSelect(id, items, label) {
            const select = document.getElementById(id);
            select.innerHTML = `<option value="">${label}</option>`;
            [...items].sort().forEach(val => {
              const opt = document.createElement("option");
              opt.value = val;
              opt.textContent = val;
              select.appendChild(opt);
            });
          }

          populateChipGroup("rarityFilter", raritySet);
          populateChipGroup("colorFilter", colorSet);
          populateChipGroup("bloomFilter", bloomSet);
          populateChipGroup("cardTypeChipGroup", typePartsSet); // âœ… ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®åˆ†å‰²ãƒãƒƒãƒ—è¡¨ç¤º
          populateChipGroup("ownedStateChipGroup", ["owned", "unowned"], false);
          populateSelect("productFilter", productSet, "åéŒ²å•†å“");
          populateSelect("tagFilterSelect", tagSet, "ã‚¿ã‚°ï¼ˆé¸æŠï¼‰"); // âœ… ã‚¿ã‚°ã¯ã‚»ãƒ¬ã‚¯ãƒˆå½¢å¼
        }

        function sortCards(list, method) {
          const sorted = [...list];
          if (method === "release") {
            sorted.sort((a, b) => {
              const ra = releaseMap[a.product] ?? "9999-12-31";
              const rb = releaseMap[b.product] ?? "9999-12-31";
              if (ra !== rb) return ra.localeCompare(rb);
              if (a.product !== b.product) return a.product.localeCompare(b.product);
              return a.id.localeCompare(b.id);
            });
          } else if (method === "id") {
            sorted.sort((a, b) => a.id.localeCompare(b.id));
          } else if (method === "name") {
            sorted.sort((a, b) => a.name.localeCompare(b.name, "ja"));
          } else if (method === "rarity") {
            const rank = { SR: 3, R: 2, N: 1 };
            sorted.sort((a, b) => (rank[b.rarity] ?? 0) - (rank[a.rarity] ?? 0));
          }
          return sorted;
        }
        
        function renderCardSelectionGallery() {
          const rawKeyword = document.getElementById("nameSearch").value.trim();
          const keyword = normalizeText(rawKeyword);
          const sortMethod = document.getElementById("sortMethod").value;

          const owned = getCheckedFromChips("ownedStateChipGroup");
          const rarity = getCheckedFromChips("rarityFilter");
          const color = getCheckedFromChips("colorFilter");
          const bloom = getCheckedFromChips("bloomFilter");
          const cardTypeFilters = getCheckedFromChips("cardTypeChipGroup");
          const product = document.getElementById("productFilter").value;
          const selectedTag = document.getElementById("tagFilterSelect").value;

          const container = document.getElementById("cardGallery");
          container.innerHTML = "";
          container.className = "card-grid";

          const countMap = {};
          if (currentDeck && decks[currentDeck]) {
            decks[currentDeck].forEach(id => {
              countMap[id] = (countMap[id] || 0) + 1;
            });
          }

          const filtered = cards.filter(card => {
            const ownedCount = card.owned ?? 0;
            const matchOwned =
              owned.length === 0 ||
              (owned.includes("owned") && ownedCount > 0) ||
              (owned.includes("unowned") && ownedCount === 0);

            const allText = normalizeText([
              card.name,
              card.id,
              card.rarity,
              card.color,
              card.bloom,
              card.hp ?? card.life ?? "",
              card.product,
              card.card_type,
              ...(card.skills ?? []),
              ...(card.tags ?? [])
            ].join(" "));

            const match = {
              rarity: rarity.length === 0 || rarity.includes(card.rarity),
              color: color.length === 0 || color.includes(card.color),
              bloom: bloom.length === 0 || bloom.includes(card.bloom),
              product: !product || card.product === product,
              tag: !selectedTag || (card.tags && card.tags.includes(selectedTag)),
              cardType:
                cardTypeFilters.length === 0 ||
                cardTypeFilters.some(type => card.card_type?.includes(type)),
              keyword: keyword === "" || allText.includes(keyword)
            };

            return matchOwned && !Object.values(match).includes(false);
          });

          const sorted = sortCards(filtered, sortMethod);

          const totalSelected = currentDeck && decks[currentDeck] ? decks[currentDeck].length : 0;
          document.getElementById("cardStats").textContent = `ğŸ§  é¸æŠæšæ•°ï¼š${totalSelected}æš`;

          sorted.forEach(card => {
            const selectedCount = countMap[card.id] || 0;
            const ownedCount = card.owned ?? 0;

            const box = document.createElement("div");
            box.className = "card-box";
            box.onclick = () => addCardToDeck(card.id);
            box.style.position = "relative";

            const img = document.createElement("img");
            img.src = card.image;
            img.alt = card.name;
            img.onerror = () => { img.src = "images/placeholder.png"; };
            box.appendChild(img);

            const info = document.createElement("div");
            info.className = "card-info";
            info.innerHTML = `
              <div style="font-weight:bold;">${card.name}</div>
              <div style="font-weight:bold;">ğŸ“„${card.id}</div>
              <div style="font-weight:bold;">âœ¨${card.rarity}ã€€ğŸƒæ‰€æŒï¼š${ownedCount}æš</div>
            `;
            box.appendChild(info);

            if (selectedCount > 0) {
              const badge = document.createElement("div");
              badge.className = "count-badge";
              badge.textContent = `Ã—${selectedCount}`;
              box.appendChild(badge);

              const minus = document.createElement("div");
              minus.className = "delete-btn";
              minus.textContent = "âˆ’";
              minus.title = "ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’1æšãƒ‡ãƒƒã‚­ã‹ã‚‰å¤–ã™";
              minus.onclick = (e) => {
                e.stopPropagation();
                const index = decks[currentDeck].indexOf(card.id);
                if (index !== -1) {
                  decks[currentDeck].splice(index, 1);
                  updateDeckUI();
                }
              };
              box.appendChild(minus);
            }

            container.appendChild(box);
          });
        }
        function classifyDeckByType(deckIds) {
          const typeCounts = {
            oshi: 0,
            cheer: 0,
            other: 0
          };

          deckIds.forEach(id => {
            const card = cards.find(c => c.id === id);
            if (!card) return;

            const type = card.card_type;
            if (type === "æ¨ã—ãƒ›ãƒ­ãƒ¡ãƒ³") {
              typeCounts.oshi += 1;
            } else if (type === "ã‚¨ãƒ¼ãƒ«") {
              typeCounts.cheer += 1;
            } else {
              typeCounts.other += 1;
            }
          });

          return typeCounts;
        }

  // âœ… èµ·å‹•æ™‚ï¼šJSONèª­ã¿è¾¼ã¿ï¼‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åˆæœŸåŒ–
  window.onload = async () => {
    try {
      const [cardRes, releaseRes] = await Promise.all([
        fetch("json_file/card_data.json"),
        fetch("json_file/release_dates.json")
      ]);
      const rawData = await cardRes.json();
      releaseMap = await releaseRes.json();

      cards = Object.entries(rawData).map(([key, card]) => ({
        id: key,
        name: card.name,
        rarity: card.rarity ?? "-",
        color: card.color ?? "-",
        bloom: card.bloom_level ?? "-",
        hp: card.hp ?? null,
        life: card.life ?? null,
        product: card.product ?? "-",
        tags: card.tags ?? [],
        skills: card.skills ?? [],
        image: card.image_url || `images/${key}.png`,
        owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
        card_type: card.card_type ?? "-"
      }));

      setupFilterChips();
      updateDeckUI();
    } catch (err) {
      console.error(err);
      alert("ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼");
    }
  };

  window.onload = async () => {
    // ğŸŒ™ ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰
    if (localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark");
    }

    // ğŸ“± ãƒ¢ãƒã‚¤ãƒ«åˆ¤å®š
    if (window.innerWidth <= 600) {
        document.body.classList.add("mobile-layout");
    }

    // ğŸ’¾ ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒƒã‚­èª­ã¿è¾¼ã¿
    const savedDecks = localStorage.getItem("deckData");
    if (savedDecks) {
        try {
        decks = JSON.parse(savedDecks);
        currentDeck = Object.keys(decks)[0] ?? null;
        } catch {
        console.warn("ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒƒã‚­ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
        }
    }
    // ğŸ´ ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    try {
        const [cardRes, releaseRes] = await Promise.all([
        fetch("json_file/card_data.json"),
        fetch("json_file/release_dates.json")
        ]);
        const rawData = await cardRes.json();
        releaseMap = await releaseRes.json();

        cards = Object.entries(rawData).map(([key, card]) => ({
        id: key,
        name: card.name,
        rarity: card.rarity ?? "-",
        color: card.color ?? "-",
        bloom: card.bloom_level ?? "-",
        hp: card.hp ?? null,
        life: card.life ?? null,
        product: card.product ?? "-",
        tags: card.tags ?? [],
        skills: card.skills ?? [],
        image: card.image_url || `images/${key}.png`,
        owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
        card_type: card.card_type ?? "-"
        }));

        setupFilterChips();
        updateDeckUI();
    } catch (err) {
        console.error(err);
        alert("ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼");
    }
  };
</script>
</body>
</html>