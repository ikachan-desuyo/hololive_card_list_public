<!DOCTYPE html>
<html lang="ja">
<!-- Version: 3.7.0-CENTRALIZED-VERSION - Enhanced mobile filter display and layout optimizations -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>ãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã‚«ãƒ¼ãƒ‰ä¸€è¦§</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      font-size: 15px;
      transition: background 0.3s, color 0.3s;
      overflow-x: hidden;
    }
  
    .dark { background: #222; color: #eee; }
    .dark table { background: #333; }
    .dark th, .dark td { border-color: #666; }
    .dark input, .dark select, .dark textarea {
      background: #444; color: #eee; border-color: #666;
    }
    .dark #csvPanel {
      background: #333 !important;
      border-color: #666 !important;
    }
      .dark #csvPanel h4 {
        color: #aaa !important;
      }

      /* CSVæ©Ÿèƒ½ãƒ‘ãƒãƒ«ã®ãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ« */
      #csvPanel {
        border: 2px solid #667eea;
        border-radius: 10px;
        padding: 15px;
        margin: 10px 0;
        background: #f8f9ff;
      }

      #csvPanel h4 {
        margin: 0 0 10px 0;
        color: #667eea;
      }

      #csvPanel textarea {
        width: 100%;
        margin-bottom: 8px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        box-sizing: border-box;
      }

      #csvPanel .button-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      #csvPanel .csv-button {
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        color: white;
      }

      #csvPanel .import-btn { background: #4CAF50; }
      #csvPanel .export-btn { background: #2196F3; }
      #csvPanel .clear-btn { background: #f44336; }    .container {
      max-width: none;
      width: fit-content;
      margin: 0 auto;
      padding: 10px;
    }
  
    .container-top {
      background: #fff;
      border-bottom: 1px solid #ccc;
      padding: 10px;
    }

    /* æ¤œç´¢ãƒ»ã‚½ãƒ¼ãƒˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡Œã®ã¿ã‚’stickyå›ºå®š */
    .sticky-controls {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 100;
      border-bottom: 1px solid #ddd;
      padding: 8px 0;
      margin-bottom: 10px;
    }

    .dark .container-top {
      background: #222;
      border-color: #444;
    }

    .dark .sticky-controls {
      background: #222 !important;
      border-color: #444 !important;
    }
  
    h2 {
      text-align: center;
      margin-bottom: 10px;
      margin-top: 0;
      position: relative;
    }
  
    .top-nav {
      position: absolute;
      top: 0;
      right: 10px;
    }
  
    .top-controls {
      display: flex;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }

    /* ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ã®ãƒœã‚¿ãƒ³é…ç½®èª¿æ•´ */
    .mobile-layout .top-nav {
      position: static;
      text-align: center;
      margin-bottom: 10px;
    }

    .mobile-layout .top-nav button {
      font-size: 12px;
      padding: 4px 8px;
      margin: 0 2px;
    }

    .mobile-layout h2 {
      font-size: 16px;
      margin-bottom: 8px;
      margin-top: 0;
      position: static;
    }

    .mobile-layout .top-controls {
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
    }

    .mobile-layout .top-controls-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
      width: 100%;
    }

    .mobile-layout .top-controls button {
      font-size: 12px;
      padding: 4px 6px;
      flex: 1;
      min-width: 0;
    }

    /* CSVæ©Ÿèƒ½ãƒœã‚¿ãƒ³ã‚’ç¢ºå®Ÿã«è¡¨ç¤º */
    .mobile-layout .top-controls-row button {
      display: block !important;
      visibility: visible !important;
      font-size: 12px;
      padding: 4px 8px;
      margin: 2px;
      flex: 1;
      white-space: nowrap;
    }

    .mobile-layout .top-controls input,
    .mobile-layout .top-controls select {
      font-size: 12px;
      padding: 4px;
      flex: 1;
      min-width: 0;
    }

    .mobile-layout #nameSearch {
      min-width: 120px;
    }

    .mobile-layout #sortMethod {
      min-width: 80px;
    }
  
    .filter-group {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 6px;
      margin-bottom: 2px;
    }
  
    .dark .filter-group {
      border-color: #666;
    }
  
    #filtersWrapper {
      display: none;
      transition: all 0.3s ease;
    }
  
    .sticky-info {
      background: #fff;
      padding: 10px 0;
      font-size: 13px;
      border-bottom: 1px solid #ccc;
      text-align: center;
    }
  
    .dark .sticky-info {
      background: #222;
      border-color: #444;
    }
  
    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
    }
  
    thead {
      position: sticky;
      top: 0;
      background: #f8f8f8;
      z-index: 50;
    }
  
    .dark thead {
      background: #333;
    }
  
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      font-size: 15px;
      vertical-align: top;
    }
  
    input[type="number"] {
      width: 32px;
      text-align: center;
    }
  
    img {
      width: 60px;
      border-radius: 4px;
      cursor: zoom-in;
      background-color: #fff;
      border: 1px solid #ddd;
    }
  
    /* âœ… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆç°¡æ˜“ï¼‰è¡¨ç¤ºå…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    #cardPreviewArea {
      padding: 8px;
    }
  
    #cardPreviewArea > div {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: flex-start;
    }
  
    #cardPreviewArea div > div {
      flex: 0 0 auto;
      width: calc((100vw - 48px) / 4);
      max-width: 96px;
      padding: 4px;
      box-sizing: border-box;
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 6px;
    }
  
    #cardPreviewArea img {
      width: 100%;
      border-radius: 4px;
      cursor: zoom-in;
      background: #fff;
      border: 1px solid #ccc;
    }
  
    #cardPreviewArea div > div div {
      font-size: 11px;
      line-height: 1.3;
      color: #333;
      margin-top: 4px;
      background: none;
      border: none;
      padding: 0;
      overflow-wrap: break-word;
    }

    .dark #cardPreviewArea div > div div {
      font-size: 11px;
      line-height: 1.3;
      color: #b9b8b8;
      margin-top: 4px;
      background: none;
      border: none;
      padding: 0;
      overflow-wrap: break-word;
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .chip {
      padding: 2px 10px;
      border: 1px solid #aaa;
      border-radius: 16px;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
      transition: 0.2s;
    }

    .chip:hover {
      background: #ddd;
    }

    .chip.selected {
      background: #0095ff;
      color: #fff;
      border-color: #007acc;
    }

    .chip.all-chip {
      font-weight: bold;
    }

    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒãƒƒãƒ—ã‚¹ã‚¿ã‚¤ãƒ« */
    .dark .chip {
      background: #444;
      color: #eee;
      border-color: #666;
    }

    .dark .chip:hover {
      background: #555;
    }

    .dark .chip.selected {
      background: #007acc;
      color: #fff;
      border-color: #005999;
    }
  
    /* âœ… ã‚¹ãƒãƒ›å°‚ç”¨è¡¨ç¤ºãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¿½åŠ èª¿æ•´ */
    .mobile-layout #cardPreviewArea div > div {
      width: calc((100vw - 32px) / 4);
      max-width: 95px;
      margin: 0.2px;
    }
  
    .mobile-layout .sticky-info {
      font-size: 11.5px;
      padding: 6px 0;
      line-height: 1.1;
    }

    .mobile-layout .sticky-controls {
      position: sticky !important;
      top: 0 !important;
      background: #fff !important;
      z-index: 100 !important;
      border-bottom: 1px solid #ddd !important;
      padding: 6px 8px !important;
      margin: 0 -8px 10px -8px !important;
    }
  
    .mobile-layout #cardPreviewArea div > div div {
      font-size: 10px;
    }

    .dark .mobile-layout .sticky-info {
      font-size: 11.5px;
      padding: 6px 0;
      line-height: 1.1;
      color: #b9b8b8;
    }

    .dark .mobile-layout .sticky-controls {
      background: #222 !important;
      border-color: #444 !important;
    }
  
    .dark .mobile-layout #cardPreviewArea div > div div {
      font-size: 10px;
      color: #b9b8b8;
    }
  
    .mobile-layout .container-top {
      padding: 4px 6px 6px 6px;
    }
  
    .mobile-layout .top-controls {
      gap: 6px;
      margin-bottom: 6px;
    }
  
    .mobile-layout h2 {
      font-size: 17px;
      margin-bottom: 6px;
    }

    /* âœ… ã‚¹ãƒãƒ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ãƒ©ãƒ™ãƒ«å…¨ä½“ã«é©ç”¨ */
    .mobile-layout .filter-group label {
      font-size: 13px;
      line-height: 1.4;
    }

    /* âœ… ãƒ©ãƒ™ãƒ«å†…ã®ãƒ†ã‚­ã‚¹ãƒˆã«ã‚‚ç›´æ¥é©ç”¨ï¼ˆæ§‹é€ ã«ã‚ˆã£ã¦å¿…è¦ï¼‰ */
    .mobile-layout .filter-group label > span,
    .mobile-layout .filter-group label > div,
    .mobile-layout .filter-group label > text,
    .mobile-layout .filter-group label * {
      font-size: 13px !important;
    }

    /* ã‚¹ãƒãƒ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã€ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãƒ©ãƒ™ãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚µã‚¤ã‚ºã‚’ç¸®å° */
    .mobile-layout .filter-row label {
      font-size: 12px !important;
      line-height: 1.2;
    }

    /* ã‚¹ãƒãƒ›ã§åéŒ²å•†å“ã‚»ãƒ¬ã‚¯ãƒˆã‚’ç”»é¢å¹…ã«åˆã‚ã›ã‚‹ */
    .mobile-layout #productFilter {
      width: 100%;
      max-width: calc(100vw - 32px); /* å·¦å³ã®ä½™ç™½åˆ†ã‚’èª¿æ•´ */
      font-size: 13px;
    }
    
    .mobile-layout #cardPreviewArea > div {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: flex-start;
    }

    /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã§ã¯é€šå¸¸ã®é…ç½®ã‚’ç¶­æŒ */
    @media (min-width: 541px) {
      .top-controls-row {
        display: contents;
      }
      
      .top-controls {
        flex-direction: row !important;
        justify-content: flex-end !important;
      }
      
      #filterToggleBtn {
        order: 1; /* æœ€å¾Œã«é…ç½® */
      }
    }

    /* ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã§ã®ç¢ºå®Ÿãªè¡¨ç¤º - çµ±åˆç‰ˆ */
    @media (max-width: 540px) {
      .top-controls-row {
        display: flex !important;
        width: 100%;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 4px;
        margin-bottom: 4px;
      }

      .top-controls-row button {
        flex: 1;
        font-size: 11px;
        padding: 4px 6px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* sticky-controls ã®ãƒ¢ãƒã‚¤ãƒ«å›ºå®šã‚’å¼·åŒ– */
      .sticky-controls {
        position: sticky !important;
        top: 0 !important;
        background: #fff !important;
        z-index: 100 !important;
        border-bottom: 1px solid #ddd !important;
        padding: 8px !important;
        margin: 0 0 10px 0 !important;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
      }

      .dark .sticky-controls {
        background: #222 !important;
        border-color: #444 !important;
        box-shadow: 0 2px 4px rgba(255,255,255,0.1) !important;
      }

      /* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤ºã®æ”¹å–„ */
      .sticky-controls #filtersWrapper {
        background: transparent !important;
        margin-top: 8px !important;
        border: none !important;
        padding: 0 !important;
      }

      .dark .sticky-controls #filtersWrapper {
        background: transparent !important;
      }

      /* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– */
      .sticky-controls .filter-group {
        background: #f8f9fa !important;
        margin-bottom: 8px !important;
        padding: 8px !important;
        border: 1px solid #dee2e6 !important;
        border-radius: 6px !important;
      }

      .dark .sticky-controls .filter-group {
        background: #333 !important;
        border-color: #555 !important;
      }

      .sticky-controls .filter-group legend {
        background: #fff !important;
        color: #495057 !important;
        padding: 2px 8px !important;
        font-size: 12px !important;
        font-weight: bold !important;
      }

      .dark .sticky-controls .filter-group legend {
        background: #222 !important;
        color: #adb5bd !important;
      }

      /* ãƒãƒƒãƒ—ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– */
      .sticky-controls .chip-group {
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 4px !important;
        margin-top: 6px !important;
      }

      .sticky-controls .chip {
        font-size: 10px !important;
        padding: 4px 8px !important;
        border-radius: 12px !important;
        background: #e9ecef !important;
        color: #495057 !important;
        border: 1px solid #ced4da !important;
        cursor: pointer !important;
        white-space: nowrap !important;
      }

      .sticky-controls .chip.selected {
        background: #007bff !important;
        color: #fff !important;
        border-color: #0056b3 !important;
      }

      .dark .sticky-controls .chip {
        background: #495057 !important;
        color: #adb5bd !important;
        border-color: #6c757d !important;
      }

      .dark .sticky-controls .chip.selected {
        background: #0056b3 !important;
        color: #fff !important;
        border-color: #004085 !important;
      }

      /* ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã®ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ– */
      .sticky-controls select {
        width: 100% !important;
        font-size: 12px !important;
        padding: 6px !important;
        background: #fff !important;
        color: #495057 !important;
        border: 1px solid #ced4da !important;
        border-radius: 4px !important;
        margin-top: 6px !important;
      }

      .dark .sticky-controls select {
        background: #444 !important;
        color: #adb5bd !important;
        border-color: #6c757d !important;
      }

      /* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åŸºæœ¬è¨­å®š */
      .sticky-controls input[type="text"] {
        font-size: 12px !important;
        padding: 6px !important;
        flex: 2 !important;
        min-width: 100px !important;
        background: #fff !important;
        color: #495057 !important;
        border: 1px solid #ced4da !important;
      }

      .dark .sticky-controls input[type="text"] {
        background: #444 !important;
        color: #adb5bd !important;
        border-color: #6c757d !important;
      }

      .sticky-controls select {
        font-size: 12px !important;
        padding: 6px !important;
        flex: 1.5 !important;
        min-width: 80px !important;
      }

      .sticky-controls button {
        font-size: 11px !important;
        padding: 6px 8px !important;
        flex: 1 !important;
        min-width: 70px !important;
        background: #007bff !important;
        color: #fff !important;
        border: 1px solid #0056b3 !important;
        border-radius: 4px !important;
      }

      .dark .sticky-controls button {
        background: #0056b3 !important;
        border-color: #004085 !important;
      }

      .sticky-controls .top-controls-row {
        margin-bottom: 0 !important;
      }
    }

    /* CSVæ©Ÿèƒ½ã®ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    @media (max-width: 540px) {
      .csv-row {
        order: -1; /* CSVæ©Ÿèƒ½ã‚’æœ€ä¸Šéƒ¨ã«è¡¨ç¤º */
        margin-bottom: 8px;
      }

      #csvPanel {
        margin: 5px 0 !important;
        padding: 10px !important;
        border-radius: 8px !important;
      }

      #csvPanel h4 {
        font-size: 14px !important;
        margin-bottom: 8px !important;
      }

      #csvPanel textarea {
        font-size: 11px !important;
        padding: 6px !important;
        margin-bottom: 6px !important;
      }

      #csvPanel .button-group {
        flex-direction: column !important;
        gap: 4px !important;
      }

      #csvPanel .csv-button {
        font-size: 11px !important;
        padding: 6px 8px !important;
        width: 100% !important;
        box-sizing: border-box;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="container-top">
      <h2>ãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã‚«ãƒ¼ãƒ‰ä¸€è¦§ 
        <span style="font-size: 12px; color: #999; font-weight: normal;" id="versionDisplay">[v3.7.0-loading...]</span>
        <button onclick="checkForUpdates()" style="font-size: 10px; margin-left: 5px; padding: 2px 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer;">æ›´æ–°ç¢ºèª</button>
      </h2>
      
        <div class="top-nav">
          <button onclick="location.href='holoca_skill_page.html'">ğŸ—‚ ã‚«ãƒ¼ãƒ‰è©³ç´°æ¤œç´¢</button>
          <button onclick="location.href='deck_builder.html'">âš”ï¸ ãƒ‡ãƒƒã‚­ä½œæˆ</button>
        </div>      <div class="top-controls">
        <!-- CSVæ©Ÿèƒ½ã‚’æœ€ä¸Šéƒ¨ã«ç§»å‹• -->
        <div class="top-controls-row csv-row">
          <button onclick="toggleCSVPanel()">ğŸ“„ CSVæ©Ÿèƒ½</button>
        </div>
        
        <!-- ãã®ä»–ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div class="top-controls-row">
          <button onclick="setViewMode('table')">ğŸ§¾ è¡¨ãƒ¢ãƒ¼ãƒ‰</button>
          <button onclick="setViewMode('compact')">ğŸ–¼ï¸ ç°¡æ˜“è¡¨ç¤º</button>
          <button onclick="toggleDarkMode()">ğŸŒ—</button>
        </div>
      </div>

      <!-- CSVæ©Ÿèƒ½ãƒ‘ãƒãƒ«ï¼ˆåˆæœŸéè¡¨ç¤ºï¼‰ -->
      <div id="csvPanel" style="display:none;">
        <h4>ğŸ“„ CSVæ©Ÿèƒ½</h4>
        <div>
          <textarea id="csvInput" rows="3" placeholder="id,æšæ•° ã®å½¢å¼ã§CSVãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
          <div class="button-group">
            <button onclick="importCSV()" class="csv-button import-btn">ğŸ“¥ CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            <button onclick="exportCSV()" class="csv-button export-btn">ğŸ“¤ æ‰€æŒCSVå–å¾—</button>
            <button onclick="clearCSVInput()" class="csv-button clear-btn">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
          </div>
        </div>
      </div>
    </div>

    <!-- å›ºå®šå¯¾è±¡ï¼šæ¤œç´¢ãƒ»ã‚½ãƒ¼ãƒˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ã¿ -->
    <div class="sticky-controls">
      <div class="top-controls-row">
        <input type="text" id="nameSearch" placeholder="ã‚«ãƒ¼ãƒ‰åæ¤œç´¢" oninput="renderTable()" />
        <select id="sortMethod" onchange="renderTable()">
          <option value="release" selected>ç™ºå£²æ—¥é †</option>
          <option value="id">ã‚«ãƒ¼ãƒ‰ç•ªå·é †</option>
          <option value="name">åå‰é †</option>
          <option value="rarity">ãƒ¬ã‚¢ãƒªãƒ†ã‚£é †</option>
        </select>
        <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤º/éè¡¨ç¤ºã‚’æœ€å¾Œã« -->
        <button onclick="toggleFilters()" id="filterToggleBtn">ğŸ”½ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤º</button>
      </div>

      <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼éƒ¨åˆ†ã‚‚sticky-controlså†…ã«ç§»å‹• -->
      <div id="filtersWrapper">
        <fieldset class="filter-group">
          <legend>æ‰€æŒçŠ¶æ…‹</legend>
          <div id="ownedStateChipGroup" class="chip-group">
            <button class="chip selected" data-value="owned" onclick="toggleChip(this)">æ‰€æŒã‚ã‚Š</button>
            <button class="chip selected" data-value="unowned" onclick="toggleChip(this)">æ‰€æŒãªã—</button>
          </div>
        </fieldset>
        
        <fieldset class="filter-group">
          <legend>ãƒ¬ã‚¢ãƒªãƒ†ã‚£</legend>
          <div id="rarityFilter" class="chip-group"></div>
        </fieldset>
        
        <fieldset class="filter-group">
          <legend>è‰²</legend>
          <div id="colorFilter" class="chip-group"></div>
        </fieldset>
        
        <fieldset class="filter-group">
          <legend>Bloom</legend>
          <div id="bloomFilter" class="chip-group"></div>
        </fieldset>

        <fieldset class="filter-group">
          <legend>ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</legend>
          <div id="cardTypeFilter" class="chip-group"></div>
        </fieldset>

        <fieldset class="filter-group">
          <legend>åéŒ²å•†å“</legend>
          <select id="productFilter" onchange="renderTable()">
            <option value="">åéŒ²å•†å“ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>

        <fieldset class="filter-group">
          <legend>ã‚¿ã‚°çµã‚Šè¾¼ã¿</legend>
          <select id="tagsFilter" onchange="renderTable()">
            <option value="">ã‚¿ã‚°ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>
      </div>
    </div>

    <div class="sticky-info">
      <div id="countDisplay" style="font-weight:bold;"></div>
      <div id="typeDisplay" style="font-weight:bold;"></div>
    </div>

    <table id="cardTable">
      <thead>
        <tr>
          <th>ç”»åƒ</th>
          <th>åå‰ï¼ç•ªå·ï¼ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</th>
          <th>ãƒ¬ã‚¢</th>
          <th>è‰²</th>
          <th>Bloom</th>
          <th>HP</th>
          <th>åéŒ²</th>
          <th>æšæ•°</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- âœ… ç°¡æ˜“è¡¨ç¤ºé ˜åŸŸï¼ˆã‚¹ãƒãƒ›æœ€é©åŒ–æ¸ˆï¼‰ -->
    <div id="cardPreviewArea" style="display:none;"></div>

    <!-- âœ… ç”»åƒã‚ºãƒ¼ãƒ è¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="imageModal" onclick="hideImageModal()" style="
      display:none;
      position:fixed;
      top:0; left:0;
      width:100vw; height:100vh;
      background:rgba(0,0,0,0.85);
      text-align:center;
      z-index:1000;
      cursor:zoom-out;">
      <img src="" style="
        margin-top:5vh;
        width:100%;
        height:auto;
        max-height:100dvh;
        object-fit:contain;">
    </div>
    <script>
      let cards = [];
      let releaseMap = {};
      let viewMode = "compact";
      let renderLimit = 100;

      const ownedLabelMap = {
        owned: "æ‰€æŒã‚ã‚Š",
        unowned: "æ‰€æŒãªã—"
      };
    
      function populateChipGroup(id, items, withAllButton = false, selectAllByDefault = true) {
        const container = document.getElementById(id);
        container.innerHTML = "";
        container.classList.add("chip-group");

        if (withAllButton) {
          const allBtn = document.createElement("button");
          allBtn.textContent = "ã™ã¹ã¦";
          allBtn.className = "chip all-chip" + (selectAllByDefault ? " selected" : "");
          allBtn.dataset.value = "ALL";
          allBtn.onclick = () => selectAllChip(allBtn);
          container.appendChild(allBtn);
        }

        items.forEach(val => {
          const btn = document.createElement("button");
          // âœ… æ‰€æŒçŠ¶æ…‹ã ã‘æ—¥æœ¬èªãƒ©ãƒ™ãƒ«ã«å¤‰æ›
          const label = id === "ownedStateChipGroup" ? ownedLabelMap[val] ?? val : val;
          btn.textContent = label;
          btn.className = "chip";
          btn.dataset.value = val;
          btn.onclick = () => toggleChip(btn);
          container.appendChild(btn);
        });
      }

      function toggleChip(btn) {
        const group = btn.parentElement;
        const allBtn = group.querySelector(".all-chip");
        if (allBtn) allBtn.classList.remove("selected");

        btn.classList.toggle("selected");
        renderTable();
      }

      function selectAllChip(allBtn) {
        const group = allBtn.parentElement;
        group.querySelectorAll(".chip").forEach(btn => btn.classList.remove("selected"));
        allBtn.classList.add("selected");
        renderTable();
      }

      function getCheckedFromChips(id) {
        const allSelected = document.querySelector(`#${id} .chip.all-chip.selected`);
        if (allSelected) return [];
        return [...document.querySelectorAll(`#${id} .chip.selected:not(.all-chip)`)].map(btn => btn.dataset.value);
      }

      function setViewMode(mode) {
        viewMode = mode;
        renderLimit = 100;
        renderTable();
      }
    
      function toggleFilters() {
        const el = document.getElementById("filtersWrapper");
        const toggleBtn = document.getElementById("filterToggleBtn");
        const isHidden = window.getComputedStyle(el).display === "none";
        
        if (isHidden) {
          el.style.display = "block";
          toggleBtn.textContent = "ğŸ”¼ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼éè¡¨ç¤º";
        } else {
          el.style.display = "none";
          toggleBtn.textContent = "ğŸ”½ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤º";
        }
      }

      function toggleCSVPanel() {
        const el = document.getElementById("csvPanel");
        const isHidden = window.getComputedStyle(el).display === "none";
        
        if (isHidden) {
          el.style.display = "block";
        } else {
          el.style.display = "none";
        }
      }

      function clearCSVInput() {
        document.getElementById("csvInput").value = "";
      }
    
      function toggleDarkMode() {
        document.body.classList.toggle("dark");
        localStorage.setItem("darkMode", document.body.classList.contains("dark"));
      }
    
      function selectAll(id) {
        document.querySelectorAll(`#${id} input[type="checkbox"]`).forEach(cb => cb.checked = true);
        renderTable();
      }
    
      function clearAll(id) {
        document.querySelectorAll(`#${id} input[type="checkbox"]`).forEach(cb => cb.checked = false);
        renderTable();
      }
    
      function showImageModal(src) {
        const modal = document.getElementById("imageModal");
        modal.querySelector("img").src = src;
        modal.style.display = "block";
      }
    
      function hideImageModal() {
        document.getElementById("imageModal").style.display = "none";
      }
      
      function setupFilters() {
        const raritySet = new Set(), colorSet = new Set(), bloomSet = new Set(), productSet = new Set(), tagSet = new Set(), cardTypeSet = new Set();
        cards.forEach(c => {
          raritySet.add(c.rarity);
          colorSet.add(c.color);
          bloomSet.add(c.bloom);
          if (!c.product.includes(",")) {
            productSet.add(c.product);
          }
          // ã‚¿ã‚°ã®å‡¦ç†ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
          if (c.tags && Array.isArray(c.tags)) {
            c.tags.forEach(tag => tagSet.add(tag));
          }
          // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’ã€Œãƒ»ã€ã§åˆ†å‰²
          const typeParts = c.card_type?.split("ãƒ»") ?? [];
          typeParts.forEach(part => cardTypeSet.add(part.trim()));
        });

        populateChipGroup("rarityFilter", [...raritySet].sort(), true, true);
        populateChipGroup("colorFilter", [...colorSet].sort(), true, true);
        populateChipGroup("bloomFilter", [...bloomSet].sort(), true, true);
        populateChipGroup("cardTypeFilter", [...cardTypeSet].sort(), true, true);
        populateChipGroup("ownedStateChipGroup", ["owned", "unowned"], false); // â†ä¸¡æ–¹é¸æŠã®ã¾ã¾

        const select = document.getElementById("productFilter");
        select.innerHTML = `<option value="">ã™ã¹ã¦ã®å•†å“</option>`;
        [...productSet].sort().forEach(val => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val;
          select.appendChild(opt);
        });

        // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®š
        const tagsSelect = document.getElementById("tagsFilter");
        if (tagsSelect) {
          tagsSelect.innerHTML = `<option value="">ã‚¿ã‚°ï¼ˆé¸æŠï¼‰</option>`;
          [...tagSet].sort().forEach(val => {
            const opt = document.createElement("option");
            opt.value = val;
            opt.textContent = val;
            tagsSelect.appendChild(opt);
          });
        }
      }
      
      // å…±é€šã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šè¤‡æ•°å•†å“åã‹ã‚‰æœ€ã‚‚æ—©ã„ç™ºå£²æ—¥ã‚’å–å¾—
      function getEarliestReleaseDate(productString) {
        const products = productString.split(',').map(p => p.trim());
        let earliestDate = "9999-12-31";
        
        for (const product of products) {
          const date = releaseMap[product];
          if (date && date < earliestDate) {
            earliestDate = date;
          }
        }
        return earliestDate;
      }

      function sortCards(cards) {
        const method = document.getElementById("sortMethod")?.value ?? "release";
        let sorted = [...cards];
        if (method === "release") {
          sorted.sort((a, b) => {
            const ra = getEarliestReleaseDate(a.product);
            const rb = getEarliestReleaseDate(b.product);
            
            // 1. ç™ºå£²æ—¥é †
            if (ra !== rb) return ra.localeCompare(rb);
            
            // 2. åŒã˜ç™ºå£²æ—¥ã®å ´åˆã€ã‚¨ãƒ¼ãƒ«ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            const aIsYell = a.card_type && a.card_type.includes("ã‚¨ãƒ¼ãƒ«");
            const bIsYell = b.card_type && b.card_type.includes("ã‚¨ãƒ¼ãƒ«");
            
            if (aIsYell !== bIsYell) {
              return aIsYell ? 1 : -1; // ã‚¨ãƒ¼ãƒ«ã‚’å¾Œã‚ã«
            }
            
            // 3. åŒã˜å•†å“å†…ã§ã¯ã‚«ãƒ¼ãƒ‰ç•ªå·é †
            return a.id.localeCompare(b.id);
          });
        } else if (method === "id") {
          sorted.sort((a, b) => {
            if (a.id !== b.id) return a.id.localeCompare(b.id);
            // åŒã˜IDã®å ´åˆã¯ç™ºå£²æ—¥é †
            const ra = getEarliestReleaseDate(a.product);
            const rb = getEarliestReleaseDate(b.product);
            return ra.localeCompare(rb);
          });
        } else if (method === "name") {
          sorted.sort((a, b) => {
            const nameCompare = a.name.localeCompare(b.name, "ja");
            if (nameCompare !== 0) return nameCompare;
            // åŒã˜åå‰ã®å ´åˆã¯ç™ºå£²æ—¥é †
            const ra = getEarliestReleaseDate(a.product);
            const rb = getEarliestReleaseDate(b.product);
            return ra.localeCompare(rb);
          });
        } else if (method === "rarity") {
          const rank = { 
            "SEC": 14, "OUR": 13, "UR": 12, "SY": 11, "OSR": 10, 
            "SR": 9, "P": 8, "S": 7, "OC": 6, "RR": 5, 
            "R": 4, "U": 3, "C": 2, "â€": 1, "-": 1 
          };
          sorted.sort((a, b) => {
            const rarityDiff = (rank[b.rarity] ?? 0) - (rank[a.rarity] ?? 0);
            if (rarityDiff !== 0) return rarityDiff;
            // åŒã˜ãƒ¬ã‚¢ãƒªãƒ†ã‚£å†…ã§ã¯ç™ºå£²æ—¥é †
            const ra = getEarliestReleaseDate(a.product);
            const rb = getEarliestReleaseDate(b.product);
            if (ra !== rb) return ra.localeCompare(rb);
            return a.id.localeCompare(b.id);
          });
        }
        return sorted;
      }
    </script>
<script>
  function renderTable() {
    const keyword = document.getElementById("nameSearch").value.toLowerCase();
    const getChecked = id => [...document.querySelectorAll(`#${id} input:checked`)].map(el => el.value);
    const ownedStates = getCheckedFromChips("ownedStateChipGroup");
    const rarity = getCheckedFromChips("rarityFilter");
    const color = getCheckedFromChips("colorFilter");
    const bloom = getCheckedFromChips("bloomFilter");
    const cardType = getCheckedFromChips("cardTypeFilter");
    const product = document.getElementById("productFilter").value.toLowerCase();
    const tagFilter = document.getElementById("tagsFilter")?.value.toLowerCase() || "";

    const tableArea = document.getElementById("cardTable");
    const previewArea = document.getElementById("cardPreviewArea");

    const filtered = cards.filter(card => {
      const count = card.owned;
      const matchOwned =
        ownedStates.length === 0 ||
        (ownedStates.includes("owned") && count > 0) ||
        (ownedStates.includes("unowned") && (!count || count == 0));
      if (!matchOwned) return false;

      const match = {
        name: !keyword || card.name.toLowerCase().includes(keyword),
        rarity: rarity.length === 0 || rarity.includes(card.rarity),
        color: color.length === 0 || color.includes(card.color),
        bloom: bloom.length === 0 || bloom.includes(card.bloom),
        cardType: cardType.length === 0 || cardType.some(type => card.card_type?.includes(type)),
        product: !product || card.product.toLowerCase().includes(product),
        tags: !tagFilter || (card.tags && Array.isArray(card.tags) && card.tags.map(t => t.toLowerCase()).includes(tagFilter))
      };
      return !Object.values(match).includes(false);
    });

    const sortedCards = sortCards(filtered);
    const displayCards = sortedCards.slice(0, renderLimit); // â† è¡¨ç¤ºåˆ†ã ã‘

    const tbody = tableArea.querySelector("tbody");
    tbody.innerHTML = "";

    // âœ… çµ±è¨ˆã¯ filtered ãƒ™ãƒ¼ã‚¹ã§å…¨ä»¶é›†è¨ˆ
    const shown = filtered.length;
    const ownedTypes = filtered.filter(c => c.owned > 0).length;
    const ownedCount = filtered.reduce((sum, c) => sum + (c.owned ?? 0), 0);
    const ratio = shown > 0 ? Math.round((ownedTypes / shown) * 100) : 0;

    if (viewMode === "table") {
      previewArea.style.display = "none";
      tableArea.style.display = "";

      displayCards.forEach(card => {
        const bloomText = card.card_type === "Buzzãƒ›ãƒ­ãƒ¡ãƒ³" ? "1stBuzz" : card.bloom;
        const productText = card.product.includes(",") ? card.product.replace(/,\s*/g, "<br>") : card.product;

        const row = document.createElement("tr");
        row.innerHTML = `
          <td><img src="${card.image}" loading="lazy" alt="${card.name}" onclick="showImageModal('${card.image}')"></td>
          <td>
            <div style="font-weight: bold;">${card.name}</div>
            <div style="font-size:13px;">ğŸ“„ ${card.id}<br>ğŸƒ ${card.card_type}</div>
          </td>
          <td>${card.rarity}</td>
          <td>${card.color}</td>
          <td>${bloomText}</td>
          <td>${card.hp ?? "-"}</td>
          <td>${productText}</td>
          <td><input type="number" min="0" value="${card.owned}" onchange="updateOwned('${card.id}', this.value)"></td>
        `;
        tbody.appendChild(row);
      });

      // âœ… ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¾Œå…¨ä»¶ã®çµ±è¨ˆã‚’è¡¨ç¤º
      document.getElementById("countDisplay").textContent =
        `æ‰€æŒæšæ•°ï¼š${ownedCount} / è¡¨ç¤ºï¼š${shown}ç¨®é¡ / æ‰€æŒç¨®é¡æ•°ï¼š${ownedTypes}(${ratio}%)`;
      document.getElementById("typeDisplay").textContent = ``;
      return;
    }

    // âœ… ç°¡æ˜“ãƒ¢ãƒ¼ãƒ‰ã¯ãã®ã¾ã¾
    tableArea.style.display = "none";
    previewArea.innerHTML = "";
    previewArea.style.display = "block";

    const container = document.createElement("div");
    const isMobile = document.body.classList.contains("mobile-layout");
    const columns = isMobile ? 4 : Math.floor(window.innerWidth / 160);
    const cardWidth = isMobile ? Math.floor((window.innerWidth - 32) / columns) : 160;

    displayCards.forEach(card => {
      const box = document.createElement("div");
      box.style.width = `${cardWidth}px`;

      const img = document.createElement("img");
      img.src = card.image;
      img.alt = card.name;
      img.loading = "lazy";
      img.style.width = "100%";
      img.style.cursor = "zoom-in";
      img.onclick = () => showImageModal(card.image);

      const info = document.createElement("div");
      info.innerHTML = `
        <div style="font-weight:bold;">${card.name}</div>
        <div style="font-size:11px;">ğŸ“„${card.id}</div>
        <div style="font-size:11px;">âœ¨${card.rarity}ğŸƒ${card.owned ?? 0}æš</div>
      `;
      box.appendChild(img);
      box.appendChild(info);
      container.appendChild(box);
    });

    previewArea.appendChild(container);

    // âœ… çµ±è¨ˆè¡¨ç¤ºï¼ˆç°¡æ˜“ãƒ¢ãƒ¼ãƒ‰ã‚‚å…¨ä»¶ãƒ™ãƒ¼ã‚¹ï¼‰
    document.getElementById("countDisplay").textContent =
      `æ‰€æŒæšæ•°ï¼š${ownedCount} / è¡¨ç¤ºï¼š${shown}ç¨®é¡ / æ‰€æŒç¨®é¡æ•°ï¼š${ownedTypes}(${ratio}%)`;
    document.getElementById("typeDisplay").textContent = "";
  }

  function updateOwned(id, value) {
    const num = Math.max(0, parseInt(value) || 0);
    localStorage.setItem("count_" + id, num);
    const card = cards.find(c => c.id === id);
    if (card) card.owned = num;
    renderTable();
  }

  function importCSV() {
    const input = document.getElementById("csvInput").value.trim().split("\n");
    input.forEach(line => {
      const [id, count] = line.split(",");
      const num = Math.max(0, parseInt(count) || 0);
      localStorage.setItem("count_" + id, num);
      const card = cards.find(c => c.id === id);
      if (card) card.owned = num;
    });
    renderTable();
    alert("CSVã‚’åæ˜ ã—ã¾ã—ãŸï¼");
  }

  function exportCSV() {
    // å…¨ã‚«ãƒ¼ãƒ‰ã‚’å«ã‚€ï¼ˆæ‰€æŒæšæ•°0ã®ã‚«ãƒ¼ãƒ‰ã‚‚å«ã‚ã‚‹ï¼‰
    const lines = cards.map(c => `${c.id},${c.owned}`);
    navigator.clipboard.writeText(lines.join("\n"))
      .then(() => alert("å…¨ã‚«ãƒ¼ãƒ‰ã®æ‰€æŒCSVã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼ˆæ‰€æŒæšæ•°0ã®ã‚«ãƒ¼ãƒ‰ã‚‚å«ã‚€ï¼‰"))
      .catch(() => alert("ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ"));
  }

  function isMobileScreen() {
    return window.innerWidth <= 540;
  }

  function updateMobileLayout() {
    const wasMobile = document.body.classList.contains("mobile-layout");
    const isMobile = isMobileScreen();
    
    if (isMobile) {
      document.body.classList.add("mobile-layout");
      
      // ãƒ¢ãƒã‚¤ãƒ«ç‰ˆã§ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æœ€é©åŒ–
      const filtersWrapper = document.getElementById('filtersWrapper');
      const filterToggleBtn = document.getElementById('filterToggleBtn');
      
      if (filtersWrapper && filterToggleBtn) {
        // ãƒ¢ãƒã‚¤ãƒ«ã§ã¯åˆæœŸçŠ¶æ…‹ã§éè¡¨ç¤º
        if (!wasMobile) {
          filtersWrapper.style.display = 'none';
          filterToggleBtn.textContent = 'ğŸ”½ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤º';
        }
      }
      
      if (!wasMobile) console.log('Switched to mobile layout - filters optimized');
    } else {
      document.body.classList.remove("mobile-layout");
      
      // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã§ã¯å¸¸ã«è¡¨ç¤º
      const filtersWrapper = document.getElementById('filtersWrapper');
      const filterToggleBtn = document.getElementById('filterToggleBtn');
      
      if (filtersWrapper && filterToggleBtn) {
        filtersWrapper.style.display = 'block';
        filterToggleBtn.textContent = 'ğŸ”¼ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼éè¡¨ç¤º';
      }
      
      if (wasMobile) console.log('Switched to desktop layout - filters always visible');
    }
  }

  window.addEventListener("resize", updateMobileLayout);

  window.addEventListener("scroll", () => {
    if (viewMode === "compact" || viewMode === "table") {
      const bottom = window.innerHeight + window.scrollY;
      const docHeight = document.body.offsetHeight;
      if (bottom >= docHeight - 100) {
        renderLimit += 40;
        renderTable();
      }
    }
  });

  window.onload = async () => {
    if (localStorage.getItem("darkMode") === "true") {
      document.body.classList.add("dark");
    }
    updateMobileLayout();

    // âœ… Service Worker ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã—ã¦è¡¨ç¤º
    try {
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          if (event.data.type === 'VERSION_INFO_RESPONSE') {
            const versionEl = document.getElementById('versionDisplay');
            if (versionEl && event.data.data) {
              versionEl.textContent = `[v${event.data.data.pageVersions['card_list.html']}-CENTRALIZED]`;
            }
          }
        };
        navigator.serviceWorker.controller.postMessage(
          { type: 'GET_VERSION_INFO' },
          [messageChannel.port2]
        );
      }
    } catch (error) {
      console.warn('Version display error:', error);
      const versionEl = document.getElementById('versionDisplay');
      if (versionEl) {
        versionEl.textContent = '[v3.7.0-CENTRALIZED]';
      }
    }

    try {
      // Try to load from localStorage first (for offline use)
      const cachedCardData = localStorage.getItem('cardData');
      const cachedReleaseData = localStorage.getItem('releaseData');
      const cacheTimestamp = localStorage.getItem('dataTimestamp');
      const now = Date.now();
      const cacheAge = now - (parseInt(cacheTimestamp) || 0);
      const maxCacheAge = 24 * 60 * 60 * 1000; // 24 hours

      let cardRaw, releaseMapData;

      // Use cached data if available and not too old, or if offline
      if (cachedCardData && cachedReleaseData && (cacheAge < maxCacheAge || !navigator.onLine)) {
        console.log('Using cached data');
        cardRaw = JSON.parse(cachedCardData);
        releaseMapData = JSON.parse(cachedReleaseData);
      } else {
        // Fetch fresh data
        console.log('Fetching fresh data');
        const [cardRes, releaseRes] = await Promise.all([
          fetch("json_file/card_data.json"),
          fetch("json_file/release_dates.json")
        ]);
        cardRaw = await cardRes.json();
        releaseMapData = await releaseRes.json();

        // Cache the data
        localStorage.setItem('cardData', JSON.stringify(cardRaw));
        localStorage.setItem('releaseData', JSON.stringify(releaseMapData));
        localStorage.setItem('dataTimestamp', now.toString());
      }

      releaseMap = releaseMapData;

      // ãƒ‡ãƒãƒƒã‚°ï¼šreleaseMapã®å†…å®¹ã‚’ç¢ºèª
      console.log('Release Map loaded:', Object.keys(releaseMap).length, 'entries');
      console.log('ã‚¯ã‚¤ãƒ³ãƒ†ãƒƒãƒˆã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ  date:', releaseMap["ãƒ–ãƒ¼ã‚¹ã‚¿ãƒ¼ãƒ‘ãƒƒã‚¯ã€Œã‚¯ã‚¤ãƒ³ãƒ†ãƒƒãƒˆã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ ã€"]);

      cards = Object.entries(cardRaw).map(([key, card]) => ({
        id: key,
        name: card.name,
        rarity: card.rarity ?? "-",
        color: card.color ?? "-",
        bloom: card.bloom_level ?? "-",
        hp: card.card_type === "ãƒ›ãƒ­ãƒ¡ãƒ³" ? card.hp : card.life ?? "-",
        product: card.product,
        image: card.image_url,
        url: `https://hololive-official-cardgame.com/cardlist/?id=${key}`,
        owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
        card_type: card.card_type ?? "-",
        tags: card.tags ?? []
      }));

      setupFilters();
      renderTable();
    } catch (err) {
      console.error(err);
      
      // Try to load from localStorage as fallback
      const cachedCardData = localStorage.getItem('cardData');
      const cachedReleaseData = localStorage.getItem('releaseData');
      
      if (cachedCardData && cachedReleaseData) {
        console.log('Network failed, using cached data as fallback');
        const cardRaw = JSON.parse(cachedCardData);
        releaseMap = JSON.parse(cachedReleaseData);
        
        cards = Object.entries(cardRaw).map(([key, card]) => ({
          id: key,
          name: card.name,
          rarity: card.rarity ?? "-",
          color: card.color ?? "-",
          bloom: card.bloom_level ?? "-",
          hp: card.card_type === "ãƒ›ãƒ­ãƒ¡ãƒ³" ? card.hp : card.life ?? "-",
          product: card.product,
          image: card.image_url,
          url: `https://hololive-official-cardgame.com/cardlist/?id=${key}`,
          owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
          card_type: card.card_type ?? "-",
          tags: card.tags ?? []
        }));

        setupFilters();
        renderTable();
        
        // Show offline message
        document.getElementById("offline-status").textContent = "âš ï¸ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ - ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ä¸­";
        document.getElementById("offline-status").style.color = "#FF9800";
      } else {
        alert("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
      }
    }
  };

  // Service Worker registration
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js')
        .then((registration) => {
          console.log('SW registered: ', registration);
          
          // Listen for messages from Service Worker
          navigator.serviceWorker.addEventListener('message', event => {
            if (event.data && event.data.type === 'CACHE_UPDATED') {
              console.log('Cache updated, forcing reload');
              window.location.reload(true);
            }
          });
          
          // Check for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // Get update message from centralized system
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => {
                  if (event.data.type === 'UPDATE_MESSAGE_RESPONSE') {
                    console.log('ğŸš€ å¼·åˆ¶æ›´æ–°:', event.data.data.details.description);
                  } else {
                    console.log('ğŸš€ å¼·åˆ¶æ›´æ–°: ã‚¨ãƒ¼ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ãŒä¿®æ­£ã•ã‚Œã¾ã—ãŸ');
                  }
                };
                
                try {
                  navigator.serviceWorker.controller.postMessage(
                    { type: 'GET_UPDATE_MESSAGE' },
                    [messageChannel.port2]
                  );
                } catch (msgError) {
                  console.log('ğŸš€ å¼·åˆ¶æ›´æ–°: ã‚¨ãƒ¼ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ãŒä¿®æ­£ã•ã‚Œã¾ã—ãŸ');
                }
                
                // Clear all caches first
                caches.keys().then(cacheNames => {
                  return Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                }).then(() => {
                  // Force reload without user confirmation
                  window.location.reload(true);
                });
              }
            });
          });
        })
        .catch((registrationError) => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }

  // Online/Offline status
  function updateOnlineStatus() {
    const statusElement = document.getElementById('offline-status');
    if (navigator.onLine) {
      statusElement.textContent = 'ğŸŸ¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ - æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­';
      statusElement.style.color = '#4CAF50';
    } else {
      statusElement.textContent = 'ğŸ”´ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ä¸­';
      statusElement.style.color = '#F44336';
    }
  }

  // Update status on page load and network changes
  window.addEventListener('online', updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);

  // âœ… æ›´æ–°ç¢ºèªæ©Ÿèƒ½ - ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
  async function checkForUpdates() {
    const statusEl = document.getElementById('versionDisplay');
    if (!statusEl) return;
    
    try {
      statusEl.textContent = 'ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’ç¢ºèªä¸­...';
      
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const messageChannel = new MessageChannel();
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ10ç§’ï¼‰
        const timeout = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Service Worker timeout')), 10000)
        );
        
        // Service Workerã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…æ©Ÿ
        const checkPromise = new Promise((resolve, reject) => {
          messageChannel.port1.onmessage = (event) => {
            if (event.data.type === 'SINGLE_PAGE_VERSION_RESPONSE') {
              resolve(event.data.data);
            } else if (event.data.type === 'SINGLE_PAGE_VERSION_ERROR') {
              reject(new Error(event.data.error));
            }
          };
        });
        
        // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®å˜ä¸€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯è¦æ±‚ã‚’é€ä¿¡
        navigator.serviceWorker.controller.postMessage(
          { type: 'CHECK_SINGLE_PAGE_VERSION', data: { page: 'card_list.html' } },
          [messageChannel.port2]
        );
        
        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
        const versionCheckResult = await Promise.race([checkPromise, timeout]);
        
        if (versionCheckResult.hasUpdates && versionCheckResult.pageInfo) {
          const pageInfo = versionCheckResult.pageInfo;
          
          // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã¿ã®è©³ç´°æƒ…å ±ã‚’ç”Ÿæˆ
          let detailMessage = `ğŸš€ ${pageInfo.page} ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸ä¸€è‡´ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ:\n\n`;
          detailMessage += `ğŸ“Š ã‚¢ãƒ—ãƒªãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${versionCheckResult.currentAppVersion}\n`;
          detailMessage += `ğŸ• ãƒã‚§ãƒƒã‚¯æ™‚åˆ»: ${new Date(versionCheckResult.timestamp).toLocaleString('ja-JP')}\n\n`;
          detailMessage += `ğŸ“„ ${pageInfo.page}:\n`;
          detailMessage += `  â”£ æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.expectedVersion}\n`;
          detailMessage += `  â”£ å®Ÿéš›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.actualVersion || 'ä¸æ˜'}\n`;
          detailMessage += `  â”£ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.cachedVersion || 'ãªã—'}\n`;
          
          // ãƒŸã‚¹ãƒãƒƒãƒã®ç†ç”±ã‚’æ—¥æœ¬èªã§èª¬æ˜
          let reasonText = '';
          switch(pageInfo.reason) {
            case 'expected_vs_actual_mismatch':
              reasonText = 'æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
              break;
            case 'actual_vs_cached_mismatch':
              reasonText = 'å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
              break;
            case 'actual_version_not_found':
              reasonText = 'å®Ÿéš›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
              break;
            case 'no_cached_version':
              reasonText = 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“';
              break;
            default:
              reasonText = pageInfo.reason;
          }
          detailMessage += `  â”— ç†ç”±: ${reasonText}\n\n`;
          
          statusEl.innerHTML = `ğŸš€ ã“ã®ãƒšãƒ¼ã‚¸ã®æ›´æ–°ãŒåˆ©ç”¨å¯èƒ½ã§ã™`;
          console.log('Single page version check details:', versionCheckResult);
          
          setTimeout(() => {
            if (confirm(detailMessage + 'ã“ã®ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã‹ï¼Ÿ')) {
              // ã‚ˆã‚Šå¼·åŠ›ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å‡¦ç†
              console.log('Starting forced cache clear and update...');
              
              // Service Workerã«å¼·åˆ¶æ›´æ–°ã‚’è¦æ±‚
              if (navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'FORCE_UPDATE' });
              }
              
              // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¬ãƒ™ãƒ«ã§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
              if ('caches' in window) {
                caches.keys().then(cacheNames => {
                  return Promise.all(cacheNames.map(cacheName => {
                    console.log('Deleting cache:', cacheName);
                    return caches.delete(cacheName);
                  }));
                }).then(() => {
                  console.log('All browser caches cleared');
                  // Service Workerã®æ›´æ–°ã‚’å¾…ã¤
                  return new Promise(resolve => setTimeout(resolve, 1000));
                }).then(() => {
                  // ã‚ˆã‚Šå¼·åŠ›ãªãƒªãƒ­ãƒ¼ãƒ‰
                  console.log('Performing hard reload...');
                  if (window.location.reload) {
                    window.location.reload(true); // å¼·åˆ¶ãƒªãƒ­ãƒ¼ãƒ‰
                  } else {
                    window.location.href = window.location.href + '?t=' + Date.now();
                  }
                }).catch(error => {
                  console.error('Cache clear failed, forcing reload anyway:', error);
                  window.location.href = window.location.href + '?t=' + Date.now();
                });
              } else {
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥APIãŒä½¿ãˆãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                window.location.href = window.location.href + '?t=' + Date.now();
              }
            } else {
              // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å†è¡¨ç¤º
              displayVersionInfo();
            }
          }, 2000);
        } else {
          statusEl.textContent = 'âœ… ã“ã®ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯æœ€æ–°ã§ã™';
          console.log('Single page version check result: Page is up to date', versionCheckResult);
          setTimeout(() => {
            displayVersionInfo();
          }, 2000);
        }
        
      } else {
        statusEl.textContent = '[v3.7.0-SW-UNAVAILABLE]';
      }
      
    } catch (error) {
      console.error('Update check failed:', error);
      statusEl.textContent = '[v3.7.0-ERROR: ' + error.message + ']';
      setTimeout(() => {
        displayVersionInfo();
      }, 3000);
    }
  }

  // âœ… ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
  async function displayVersionInfo() {
    const statusEl = document.getElementById('versionDisplay');
    if (!statusEl) return;
    
    try {
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          if (event.data.type === 'VERSION_INFO_RESPONSE') {
            if (event.data.data && event.data.data.pageVersions) {
              statusEl.textContent = `[v${event.data.data.pageVersions['card_list.html']}-CENTRALIZED]`;
            }
          }
        };
        navigator.serviceWorker.controller.postMessage(
          { type: 'GET_VERSION_INFO' },
          [messageChannel.port2]
        );
      } else {
        statusEl.textContent = '[v3.7.0-CENTRALIZED]';
      }
    } catch (error) {
      console.warn('Version display error:', error);
      statusEl.textContent = '[v3.4.0-CENTRALIZED]';
    }
  }
</script>

<div style="margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-top: 1px solid rgba(0,0,0,0.1); text-align: center; font-size: 0.85em; color: #666;">
  <p><strong>æ¨©åˆ©è¡¨è¨˜ãƒ»å…è²¬äº‹é …</strong></p>
  <p>ã€Œãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã€ã€Œhololiveã€ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ã®å•†æ¨™ã§ã™ã€‚</p>
  <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ã¨ã¯ç„¡é–¢ä¿‚ã®éå…¬å¼ãƒ•ã‚¡ãƒ³ãƒ¡ã‚¤ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
  <p>ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®è‘—ä½œæ¨©ã¯å„æ¨©åˆ©è€…ã«å¸°å±ã—ã¾ã™ã€‚</p>
  <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã«ã‚ˆã‚Šç”Ÿã˜ãŸæå®³ã«ã¤ã„ã¦ã€ä½œæˆè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
  <p style="margin-top: 10px;">Â© 2025 Hololive Card Game Management Tool (éå…¬å¼)</p>
</div>

</body>
</html>