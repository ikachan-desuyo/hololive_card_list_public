<!DOCTYPE html>
<html lang="ja">
<!-- Version: 3.7.0-CENTRALIZED-VERSION - Enhanced sorting with product filter consistency -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta name="cache-bust" content="v3.2-sort-improvements-20250122">
  <meta name="last-modified" content="Wed, 22 Jul 2025 13:00:00 GMT">
  <title>ã‚«ãƒ¼ãƒ‰è©³ç´°æ¤œç´¢ãƒšãƒ¼ã‚¸</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      font-size: 15px;
      transition: background 0.3s, color 0.3s;
      overflow-x: hidden;
      padding-bottom: 50px; /* æœ€ä¸‹éƒ¨ã«ä½™ç™½ã‚’è¿½åŠ  */
    }

    .dark {
      background: #222;
      color: #eee;
    }

    .dark table {
      background: #333;
    }

    .dark th, .dark td {
      border-color: #666;
    }

    .dark input, .dark select, .dark textarea {
      background: #444;
      color: #eee;
      border-color: #666;
    }

    .container {
      max-width: none;
      width: fit-content;
      margin: 0 auto;
      padding: 10px 10px 30px 10px; /* ä¸‹éƒ¨ã«ä½™ç™½ã‚’è¿½åŠ  */
    }

    .top-bar {
      position: sticky;
      top: 0;
      background: #fff;
      z-index: 100;
      border-bottom: 1px solid #ccc;
      padding: 10px;
    }

    .dark .top-bar {
      background: #222;
      border-color: #444;
    }

    .top-bar .nav-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }

    .top-bar .nav-row:last-child {
      margin-bottom: 0;
    }

    .top-bar button {
      padding: 6px 10px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fff;
      margin-right: 5px;
    }

    .dark .top-bar button {
      background: #444;
      color: #eee;
      border-color: #666;
    }

    .top-bar button:hover {
      background: #f0f0f0;
    }

    .dark .top-bar button:hover {
      background: #555;
    }

    h2 {
      text-align: center;
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    .filter-group {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .dark .filter-group {
      border-color: #666;
    }

    .filter-group legend {
      font-weight: bold;
      padding: 0 6px;
    }

    #filtersWrapper {
      display: none;
    }

    .filter-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .filter-row label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: auto;
      margin-bottom: 30px; /* ãƒ†ãƒ¼ãƒ–ãƒ«ä¸‹éƒ¨ã«ä½™ç™½ã‚’è¿½åŠ  */
    }

    thead {
      position: sticky;
      top: 0;
      background: #f8f8f8;
      z-index: 50;
    }
    .dark thead {
      background: #333;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      font-size: 14px;
      text-align: left;
      vertical-align: top;
    }
    .dark th, .dark td {
      border-color: #666;
    }

    th:nth-child(2) {
      white-space: nowrap;
    }

    td:nth-child(2) {
      min-width: 140px;
      max-width: 180px;
      word-break: break-word;
    }

    td.name-cell .meta {
      margin-top: 4px;
      padding: 4px;
      border-top: 1px dashed #ccc;
      font-size: 13px;
      color: #555;
      line-height: 1.4;
    }
    .dark td.name-cell .meta {
      border-top: 1px dashed #666;
      color: #aaa;
    }

    td:nth-child(8), th:nth-child(8) {
      word-break: break-word;
      min-width: 320px;
    }

    input[type="number"] {
      width: 40px;
      background-color: #fff !important;
      color: #000;
      border: 1px solid #ccc;
    }
    .dark input[type="number"] {
      background-color: #444 !important;
      color: #eee;
      border-color: #666;
    }

    img {
      width: 60px;
      border-radius: 4px;
      cursor: zoom-in;
      background-color: #fff;
      border: 1px solid #ddd;
    }

    select {
      font-size: 14px;
      padding: 6px;
      max-width: 200px;
    }

    input[type="text"] {
      font-size: 14px;
      padding: 6px;
      width: 200px;
    }

    img.skill-icon {
      border: none;
      outline: none;
      background: transparent;
    }

    .chip-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .chip {
      padding: 6px 12px;
      border: 1px solid #aaa;
      border-radius: 16px;
      background: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
      user-select: none;
      transition: 0.2s;
    }

    .chip:hover {
      background: #ddd;
    }

    .chip.selected {
      background: #0095ff;
      color: #fff;
      border-color: #007acc;
    }

    .chip.all-chip {
      font-weight: bold;
    }

    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒãƒƒãƒ—ã‚¹ã‚¿ã‚¤ãƒ« */
    .dark .chip {
      background: #444;
      color: #eee;
      border-color: #666;
    }

    .dark .chip:hover {
      background: #555;
    }

    .dark .chip.selected {
      background: #007acc;
      color: #fff;
      border-color: #005999;
    }

    /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
    @media (max-width: 768px) {
      body {
        padding-bottom: 80px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯æ›´ã«ä½™ç™½ã‚’å¢—ã‚„ã™ */
      }
      
      .container {
        padding: 5px 5px 50px 5px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ã€ä½†ã—ä¸‹éƒ¨ä½™ç™½ã¯ç¢ºä¿ */
      }
      
      table {
        margin-bottom: 50px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ãƒ†ãƒ¼ãƒ–ãƒ«ä¸‹éƒ¨ä½™ç™½ã‚’å¢—ã‚„ã™ */
      }
      
      th, td {
        padding: 6px 4px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚»ãƒ«å†…ã®ä½™ç™½ã‚’èª¿æ•´ */
        font-size: 13px;
      }
      
      input[type="text"] {
        width: 160px; /* ãƒ¢ãƒã‚¤ãƒ«ã§å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’çŸ­ã */
      }
      
      select {
        max-width: 160px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚’çŸ­ã */
      }

      .top-bar .nav-row {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
        gap: 5px;
      }

      .top-bar .nav-row:nth-child(2) {
        justify-content: flex-start; /* æ¤œç´¢ãƒ»ã‚½ãƒ¼ãƒˆè¡Œã¯å·¦å¯„ã› */
      }

      .top-bar .nav-row > div {
        display: flex;
        justify-content: flex-start;
        flex-wrap: wrap;
        gap: 3px;
      }

      .top-bar .nav-row h2 {
        font-size: 16px; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’å°ã•ã */
        text-align: center;
        flex: 1;
        margin: 0 5px;
      }

      .top-bar .nav-row h2 span {
        font-size: 9px; /* ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¡¨ç¤ºã‚’ã•ã‚‰ã«å°ã•ã */
      }

      .top-bar button {
        font-size: 11px;
        padding: 4px 6px;
        margin-right: 0;
      }

      .controls {
        flex-direction: row;
        gap: 5px;
        align-items: center;
        justify-content: flex-start;
        flex-wrap: wrap;
      }

      .controls input,
      .controls select,
      .controls button {
        width: auto;
        box-sizing: border-box;
        flex: none;
      }

      .controls input[type="text"] {
        width: 140px; /* æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ã‚’å°‘ã—å°ã•ã */
        font-size: 12px;
      }

      .controls select {
        max-width: 100px; /* ã‚½ãƒ¼ãƒˆé¸æŠã‚’å°ã•ã */
        font-size: 12px;
      }

      .controls button {
        padding: 5px 8px;
        font-size: 11px;
      }
    }

    /* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã®JSåˆ¶å¾¡ã‚¯ãƒ©ã‚¹ */
    .mobile-layout .top-bar {
      padding: 5px;
    }

    .mobile-layout .container {
      padding: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="nav-row">
        <div>
          <button onclick="location.href='index.html'">ğŸ  ãƒ›ãƒ¼ãƒ </button>
          <button onclick="location.href='card_list.html'">ğŸƒ ã‚«ãƒ¼ãƒ‰ä¸€è¦§</button>
          <button onclick="location.href='deck_builder.html'">âš”ï¸ ãƒ‡ãƒƒã‚­ä½œæˆ</button>
        </div>
                <h2 style="margin: 0;">ã‚«ãƒ¼ãƒ‰è©³ç´°æ¤œç´¢ 
          <span style="font-size: 12px; color: #999; font-weight: normal;" id="versionDisplay">[v3.8.0-loading...]</span>
          <button onclick="checkForUpdates()" style="font-size: 10px; margin-left: 5px; padding: 2px 6px; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer;">æ›´æ–°ç¢ºèª</button>
        </h2>
        <button onclick="toggleDarkMode()" style="padding: 2px 6px; font-size: 14px; min-width: auto; width: 28px; height: 28px;">ğŸŒ—</button>
      </div>
      <div class="nav-row">
        <div class="controls">
          <input type="text" id="keywordSearch" placeholder="ã™ã¹ã¦ã®é …ç›®ã‹ã‚‰æ¤œç´¢..." oninput="renderTable()" style="width: 200px; font-size: 14px;" />
          <select id="sortMethod" onchange="renderTable()" style="font-size: 14px;">
            <option value="release" selected>ç™ºå£²æ—¥é †</option>
            <option value="id">ã‚«ãƒ¼ãƒ‰ç•ªå·é †</option>
            <option value="name">åå‰é †</option>
            <option value="rarity">ãƒ¬ã‚¢ãƒªãƒ†ã‚£é †</option>
          </select>
          <button onclick="toggleFilters()" style="font-size: 14px;">ğŸ”½ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¡¨ç¤ºï¼éè¡¨ç¤º</button>
        </div>
      </div>
      <div id="filtersWrapper">
        <fieldset class="filter-group">
          <legend>æ‰€æŒçŠ¶æ…‹</legend>
          <div id="ownedStateChipGroup" class="chip-group"></div>
        </fieldset>

        <fieldset class="filter-group">
          <legend>ãƒ¬ã‚¢ãƒªãƒ†ã‚£</legend>
          <div id="rarityFilter" class="chip-group"></div>
        </fieldset>
        
        <fieldset class="filter-group">
          <legend>è‰²</legend>
          <div id="colorFilter" class="chip-group"></div>
        </fieldset>
        
        <fieldset class="filter-group">
          <legend>Bloom</legend>
          <div id="bloomFilter" class="chip-group"></div>
        </fieldset>

        <fieldset class="filter-group">
          <legend>ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</legend>
          <div id="cardTypeFilter" class="chip-group"></div>
        </fieldset>

        <fieldset class="filter-group">
          <legend>åéŒ²å•†å“</legend>
          <select id="productFilter" onchange="renderTable()">
            <option value="">åéŒ²å•†å“ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>

        <fieldset class="filter-group">
          <legend>ã‚¿ã‚°çµã‚Šè¾¼ã¿</legend>
          <select id="tagsFilter" onchange="renderTable()">
            <option value="">ã‚¿ã‚°ï¼ˆé¸æŠï¼‰</option>
          </select>
        </fieldset>
      </div>
    </div>

    <table id="cardTable">
      <thead>
        <tr>
          <th>ç”»åƒ</th>
          <th>åå‰ï¼ç•ªå·ï¼ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</th>
          <th>ãƒ¬ã‚¢</th>
          <th>è‰²</th>
          <th>Bloom</th>
          <th>HP</th>
          <th>tags</th>
          <th>skills</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div id="imageModal" onclick="hideImageModal()" style="
      display:none;
      position:fixed;
      top:0; left:0;
      width:100vw; height:100vh;
      background:rgba(0,0,0,0.85);
      text-align:center;
      z-index:1000;
      cursor:zoom-out;">
      <img src="" style="
        margin-top:5vh;
        width:100%;
        height:auto;
        max-height:100dvh;
        object-fit:contain;">
    </div>

    <div id="offline-status" style="position: fixed; bottom: 10px; right: 10px; font-size: 12px; padding: 5px 10px; border-radius: 5px; background: rgba(255,255,255,0.9);"></div>

    <script>
      let cards = [];
      let releaseMap = {};
      let renderLimit = 100;

      function toggleChip(btn) {
        const group = btn.parentElement;
        const allBtn = group.querySelector(".all-chip");
        if (allBtn) allBtn.classList.remove("selected");
        btn.classList.toggle("selected");
        renderTable();
      }

      function selectAllChip(allBtn) {
        const group = allBtn.parentElement;
        group.querySelectorAll(".chip").forEach(btn => btn.classList.remove("selected"));
        allBtn.classList.add("selected");
        renderTable();
      }

      function getCheckedFromChips(id) {
        const allSelected = document.querySelector(`#${id} .chip.all-chip.selected`);
        if (allSelected) return [];
        return [...document.querySelectorAll(`#${id} .chip.selected:not(.all-chip)`)].map(btn => btn.dataset.value);
      }
    
      function toggleFilters() {
        const el = document.getElementById("filtersWrapper");
        const isHidden = window.getComputedStyle(el).display === "none";
        el.style.display = isHidden ? "block" : "none";
      }
    
      function toggleDarkMode() {
        document.body.classList.toggle("dark");
        localStorage.setItem("darkMode", document.body.classList.contains("dark"));
      }

      function isMobileScreen() {
        return window.innerWidth <= 540;
      }

      function updateMobileLayout() {
        if (isMobileScreen()) {
          document.body.classList.add("mobile-layout");
        } else {
          document.body.classList.remove("mobile-layout");
        }
      }

      window.addEventListener("resize", updateMobileLayout);
    
      function selectAll(id) {
        document.querySelectorAll(`#${id} input[type="checkbox"]`).forEach(cb => cb.checked = true);
        renderTable();
      }
    
      function clearAll(id) {
        document.querySelectorAll(`#${id} input[type="checkbox"]`).forEach(cb => cb.checked = false);
        renderTable();
      }
    
      function showImageModal(src) {
        const modal = document.getElementById("imageModal");
        modal.querySelector("img").src = src;
        modal.style.display = "block";
      }
    
      function hideImageModal() {
        document.getElementById("imageModal").style.display = "none";
      }
    
      // å…±é€šã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šè¤‡æ•°å•†å“åã‹ã‚‰æœ€ã‚‚æ—©ã„ç™ºå£²æ—¥ã‚’å–å¾—
      function getEarliestReleaseDate(productString) {
        const products = productString.split(',').map(p => p.trim());
        let earliestDate = "9999-12-31";
        
        for (const product of products) {
          const date = releaseMap[product];
          if (date && date < earliestDate) {
            earliestDate = date;
          }
        }
        return earliestDate;
      }

      // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã•ã‚ŒãŸå•†å“ã«åŸºã¥ãç™ºå£²æ—¥å–å¾—ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ™‚å°‚ç”¨ï¼‰
      function getFilteredReleaseDate(productString, filteredProduct) {
        if (!filteredProduct) {
          return getEarliestReleaseDate(productString);
        }
        
        const products = productString.split(',').map(p => p.trim());
        const matchingProduct = products.find(p => p.toLowerCase().includes(filteredProduct));
        
        if (matchingProduct && releaseMap[matchingProduct]) {
          return releaseMap[matchingProduct];
        }
        
        return getEarliestReleaseDate(productString);
      }

      function sortCards(cards) {
        const method = document.getElementById("sortMethod")?.value ?? "release";
        // åéŒ²å•†å“ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®å€¤ã‚’å–å¾—ï¼ˆholoca_skill_pageã§ã¯è¤‡æ•°ã®å•†å“ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒã‚ã‚‹å¯èƒ½æ€§ã‚’è€ƒæ…®ï¼‰
        const productFilter = document.getElementById("productFilter")?.value?.toLowerCase() || 
                             document.querySelector('select[id*="product"]')?.value?.toLowerCase() || "";
        const sorted = [...cards];
    
        if (method === "release") {
          sorted.sort((a, b) => {
            // 1. ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å•†å“ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®å•†å“ã®ç™ºå£²æ—¥ã‚’å„ªå…ˆ
            const ra = getFilteredReleaseDate(a.product, productFilter);
            const rb = getFilteredReleaseDate(b.product, productFilter);
            if (ra !== rb) return ra.localeCompare(rb);
            
            // 2. åŒã˜ç™ºå£²æ—¥ã®å ´åˆã€ã‚¨ãƒ¼ãƒ«ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            const aIsYell = a.card_type && a.card_type.includes("ã‚¨ãƒ¼ãƒ«");
            const bIsYell = b.card_type && b.card_type.includes("ã‚¨ãƒ¼ãƒ«");
            
            if (aIsYell !== bIsYell) {
              return aIsYell ? 1 : -1; // ã‚¨ãƒ¼ãƒ«ã‚’å¾Œã‚ã«
            }
            
            // 3. åŒã˜å•†å“å†…ã§ã¯ã‚«ãƒ¼ãƒ‰ç•ªå·é †
            return a.id.localeCompare(b.id);
          });
        } else if (method === "id") {
          sorted.sort((a, b) => {
            if (a.id !== b.id) return a.id.localeCompare(b.id);
            // åŒã˜IDã®å ´åˆã¯ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å•†å“ã®ç™ºå£²æ—¥é †
            const ra = getFilteredReleaseDate(a.product, productFilter);
            const rb = getFilteredReleaseDate(b.product, productFilter);
            return ra.localeCompare(rb);
          });
        } else if (method === "name") {
          sorted.sort((a, b) => {
            const nameCompare = a.name.localeCompare(b.name, "ja");
            if (nameCompare !== 0) return nameCompare;
            // åŒã˜åå‰ã®å ´åˆã¯ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å•†å“ã®ç™ºå£²æ—¥é †
            const ra = getFilteredReleaseDate(a.product, productFilter);
            const rb = getFilteredReleaseDate(b.product, productFilter);
            return ra.localeCompare(rb);
          });
        } else if (method === "rarity") {
          const rank = { 
            "SEC": 14, "OUR": 13, "UR": 12, "SY": 11, "OSR": 10, 
            "SR": 9, "P": 8, "S": 7, "OC": 6, "RR": 5, 
            "R": 4, "U": 3, "C": 2, "â€": 1, "-": 1 
          };
          sorted.sort((a, b) => {
            const rarityDiff = (rank[b.rarity] ?? 0) - (rank[a.rarity] ?? 0);
            if (rarityDiff !== 0) return rarityDiff;
            // åŒã˜ãƒ¬ã‚¢ãƒªãƒ†ã‚£å†…ã§ã¯ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å•†å“ã®ç™ºå£²æ—¥é †
            const ra = getFilteredReleaseDate(a.product, productFilter);
            const rb = getFilteredReleaseDate(b.product, productFilter);
            if (ra !== rb) return ra.localeCompare(rb);
            return a.id.localeCompare(b.id);
          });
        }
    
        return sorted;
      }
      function setupFilters() {
        const raritySet = new Set(), colorSet = new Set(), bloomSet = new Set(), productSet = new Set(), tagSet = new Set(), cardTypeSet = new Set();
        cards.forEach(c => {
          raritySet.add(c.rarity);
          colorSet.add(c.color);
          bloomSet.add(c.bloom);
          if (!c.product.includes(",")) {
            productSet.add(c.product);
          }
          c.tags.forEach(tag => tagSet.add(tag));
          // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’ã€Œãƒ»ã€ã§åˆ†å‰²
          const typeParts = c.card_type?.split("ãƒ»") ?? [];
          typeParts.forEach(part => cardTypeSet.add(part.trim()));
        });

      function populateSelect(id, items, label) {
        const select = document.getElementById(id);
        select.innerHTML = `<option value="">${label}</option>`;
        [...items].sort().forEach(val => {
          const opt = document.createElement("option");
          opt.value = val;
          opt.textContent = val;
          select.appendChild(opt);
        });
      }

      function populateChipGroup(id, items, withAllButton = false, selectAllByDefault = true) {
        const container = document.getElementById(id);
        container.innerHTML = "";
        container.classList.add("chip-group");

        const ownedLabelMap = {
          owned: "æ‰€æŒã‚ã‚Š",
          unowned: "æ‰€æŒãªã—"
        };

        if (withAllButton) {
          const allBtn = document.createElement("button");
          allBtn.textContent = "ã™ã¹ã¦";
          allBtn.className = "chip all-chip" + (selectAllByDefault ? " selected" : "");
          allBtn.dataset.value = "ALL";
          allBtn.onclick = () => selectAllChip(allBtn);
          container.appendChild(allBtn);
        }

        items.forEach(val => {
          const btn = document.createElement("button");
          const label = id === "ownedStateChipGroup" ? ownedLabelMap[val] ?? val : val;
          btn.textContent = label;
          btn.className = "chip";
          btn.dataset.value = val;
          btn.onclick = () => toggleChip(btn);
          container.appendChild(btn);
        });
      }

      populateChipGroup("rarityFilter", [...raritySet].sort(), true, true);
      populateChipGroup("colorFilter", [...colorSet].sort(), true, true);
      populateChipGroup("bloomFilter", [...bloomSet].sort(), true, true);
      populateChipGroup("cardTypeFilter", [...cardTypeSet].sort(), true, true);
      populateChipGroup("ownedStateChipGroup", ["owned", "unowned"], true, true);

      populateSelect("productFilter", productSet, "åéŒ²å•†å“");
      populateSelect("tagsFilter", tagSet, "ã‚¿ã‚°ï¼ˆé¸æŠï¼‰");
    }

    const iconImageMap = {
      red: "images/TCG-ColorArtIcon-Red.png",
      blue: "images/TCG-ColorArtIcon-Blue.png",
      yellow: "images/TCG-ColorArtIcon-Yellow.png",
      green: "images/TCG-ColorArtIcon-Green.png",
      purple: "images/TCG-ColorArtIcon-Purple.png",
      white: "images/TCG-ColorArtIcon-White.png",
      any: "images/TCG-ColorArtIcon-Colorless.png"
    };

    const tokkouImageMap = {
      'èµ¤+50': "images/tokkou_50_red.png",
      'é’+50': "images/tokkou_50_blue.png",
      'é»„+50': "images/tokkou_50_yellow.png",
      'ç·‘+50': "images/tokkou_50_green.png",
      'ç´«+50': "images/tokkou_50_purple.png",
      'ç™½+50': "images/tokkou_50_white.png"
    };

    function renderSkills(skills) {
      return skills.map(skill => {
        // ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¤ã‚³ãƒ³
        const iconHTML = (skill.icons?.main ?? [])
          .map(icon => {
            const src = iconImageMap[icon.toLowerCase()];
            return src
              ? `<img src="${src}" alt="${icon}" class="skill-icon" style="height:20px; max-width:24px; object-fit:contain; background:transparent; vertical-align:middle;" />`
              : icon;
          })
          .join(" ");

        // ç‰¹æ”»ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆany ã¯é™¤å¤–ï¼‰
        const tokkouHTML = (skill.icons?.tokkou ?? [])
          .filter(t => tokkouImageMap[t.toLowerCase()])
          .map(tokkou => {
            const src = tokkouImageMap[tokkou.toLowerCase()];
            return `<img src="${src}" alt="ç‰¹æ”»:${tokkou}" class="skill-icon" style="height:52px; max-width:56px; object-fit:contain; background:transparent; vertical-align:middle;" />`;
          })
          .join(" ");

        const iconsBlock = (iconHTML || tokkouHTML)
          ? `<br>${iconHTML}${tokkouHTML ? "ï½œ" + tokkouHTML : ""}`
          : "";

        // è¡¨ç¤ºã‚¿ã‚¤ãƒ—åˆ¥ã«å‡¦ç†
        if (skill.text) {
          return `<b>ã€${skill.type}ã€‘</b>${iconsBlock}<br>${skill.text}`;
        } else if (skill.type === "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰") {
          const subtype = skill.subtype ? `<b>ã€${skill.subtype}ã€‘</b>` : "";
          const name = skill.name ?? "";
          const desc = skill.description ?? "";
          return `${subtype}${iconsBlock}<br>${name}<br>${desc}`;
        } else {
          const typePart = `<b>ã€${skill.type}ã€‘</b>`;
          const namePart = skill.name ? `[${skill.name}]` : "";
          const dmg = skill.dmg ? `ï¼ˆ${skill.dmg}ï¼‰` : "";
          const subtype = skill.subtype ? `<br>${skill.subtype}` : "";
          const desc = skill.description ?? "";
          return `${typePart}${namePart}${dmg}${subtype}${iconsBlock}<br>${desc}`;
        }
      }).join("<br><br>");
    }

    function renderTable() {
      const keyword = document.getElementById("keywordSearch").value.toLowerCase();
      const getChecked = id => [...document.querySelectorAll(`#${id} input:checked`)].map(el => el.value);
      const ownedStates = getCheckedFromChips("ownedStateChipGroup");
      const rarity = getCheckedFromChips("rarityFilter");
      const color = getCheckedFromChips("colorFilter");
      const bloom = getCheckedFromChips("bloomFilter");
      const cardType = getCheckedFromChips("cardTypeFilter");
      const product = document.getElementById("productFilter").value.toLowerCase();
      const tagFilter = document.getElementById("tagsFilter").value.toLowerCase();

      const tbody = document.querySelector("#cardTable tbody");
      tbody.innerHTML = "";

      const filtered = cards.filter(card => {
        const count = card.owned;
        const matchOwned = 
          ownedStates.length === 0 ||
          (ownedStates.includes("owned") && count > 0) ||
          (ownedStates.includes("unowned") && (!count || count == 0));
        if (!matchOwned) return false;

        const allText = [
          card.name, card.id, card.rarity, card.color, card.bloom,
          card.hp ?? card.life ?? "", card.product, card.card_type,
          card.tags.join(" "), renderSkills(card.skills).replace(/<br>/g, " ")
        ].join(" ").toLowerCase();

        const match = {
          rarity: rarity.length === 0 || rarity.includes(card.rarity),
          color: color.length === 0 || color.includes(card.color),
          bloom: bloom.length === 0 || bloom.includes(card.bloom),
          cardType: cardType.length === 0 || cardType.some(type => card.card_type?.includes(type)),
          product: !product || card.product.toLowerCase().includes(product),
          keyword: !keyword || allText.includes(keyword),
          tags: !tagFilter || card.tags.map(t => t.toLowerCase()).includes(tagFilter)
        };

        return !Object.values(match).includes(false);
      });

      const sortedCards = sortCards(filtered);

      sortedCards.slice(0, renderLimit).forEach(card => {
        const bloomText = card.card_type === "Buzzãƒ›ãƒ­ãƒ¡ãƒ³" ? "1stBuzz" : card.bloom;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td><img src="${card.image}" loading="lazy" alt="${card.name}" onclick="showImageModal('${card.image}')"></td>
          <td class="name-cell">
            <div style="font-weight: bold;">${card.name}</div>
            <div class="meta">ğŸ“„ ${card.id}<br>ğŸƒ ${card.card_type}</div>
          </td>
          <td>${card.rarity}</td>
          <td>${card.color}</td>
          <td>${bloomText}</td>
          <td>${card.hp ?? card.life ?? "-"}</td>
          <td>${card.tags.join("<br>")}</td>
          <td>${renderSkills(card.skills)}</td>
        `;
        tbody.appendChild(row);
      });
    }

    window.onload = async () => {
      console.log('ï¿½ HOLOCA SKILL PAGE v2.7-UPDATE - RESTORED UPDATE NOTIFICATIONS ï¿½');
      console.log('â° Loaded at:', new Date().toLocaleString());
      
      if (localStorage.getItem("darkMode") === "true") {
        document.body.classList.add("dark");
      }
      
      updateMobileLayout();

      try {
        // Try to load from localStorage first (for offline use)
        const cachedCardData = localStorage.getItem('cardData');
        const cachedReleaseData = localStorage.getItem('releaseData');
        const cacheTimestamp = localStorage.getItem('dataTimestamp');
        const now = Date.now();
        const cacheAge = now - (parseInt(cacheTimestamp) || 0);
        const maxCacheAge = 24 * 60 * 60 * 1000; // 24 hours

        let rawData, releaseMapData;

        // Use cached data if available and not too old, or if offline
        if (cachedCardData && cachedReleaseData && (cacheAge < maxCacheAge || !navigator.onLine)) {
          console.log('Using cached data');
          rawData = JSON.parse(cachedCardData);
          releaseMapData = JSON.parse(cachedReleaseData);
        } else {
          // Fetch fresh data
          console.log('Fetching fresh data');
          const [cardRes, releaseRes] = await Promise.all([
            fetch("json_file/card_data.json"),
            fetch("json_file/release_dates.json")
          ]);
          rawData = await cardRes.json();
          releaseMapData = await releaseRes.json();

          // Cache the data
          localStorage.setItem('cardData', JSON.stringify(rawData));
          localStorage.setItem('releaseData', JSON.stringify(releaseMapData));
          localStorage.setItem('dataTimestamp', now.toString());
        }

        releaseMap = releaseMapData;

        cards = Object.entries(rawData).map(([key, card]) => ({
          id: key,
          name: card.name,
          rarity: card.rarity ?? "-",
          color: card.color ?? "-",
          bloom: card.bloom_level ?? "-",
          hp: card.hp ?? null,
          life: card.life ?? null,
          product: card.product ?? "-",
          tags: card.tags ?? [],
          skills: card.skills ?? [],
          image: card.image_url,
          owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
          card_type: card.card_type ?? "-"
        }));

        setupFilters();
        renderTable();
      } catch (err) {
        console.error(err);
        
        // Try to load from localStorage as fallback
        const cachedCardData = localStorage.getItem('cardData');
        const cachedReleaseData = localStorage.getItem('releaseData');
        
        if (cachedCardData && cachedReleaseData) {
          console.log('Network failed, using cached data as fallback');
          const rawData = JSON.parse(cachedCardData);
          releaseMap = JSON.parse(cachedReleaseData);
          
          cards = Object.entries(rawData).map(([key, card]) => ({
            id: key,
            name: card.name,
            rarity: card.rarity ?? "-",
            color: card.color ?? "-",
            bloom: card.bloom_level ?? "-",
            hp: card.hp ?? null,
            life: card.life ?? null,
            product: card.product ?? "-",
            tags: card.tags ?? [],
            skills: card.skills ?? [],
            image: card.image_url,
            owned: parseInt(localStorage.getItem("count_" + key) ?? "0"),
            card_type: card.card_type ?? "-"
          }));

          setupFilters();
          renderTable();
        } else {
          alert("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        }
      }
    };

    // Service Worker registration with enhanced update notification for mobile
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
            
            // Listen for messages from Service Worker
            navigator.serviceWorker.addEventListener('message', event => {
              if (event.data && event.data.type === 'CACHE_UPDATED') {
                console.log('Cache updated, forcing reload');
                window.location.reload(true);
              }
            });
            
            // Check for updates
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New content available, reload the page immediately
                  console.log('ğŸš€ å¼·åˆ¶æ›´æ–°: ã‚¨ãƒ¼ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ãŒä¿®æ­£ã•ã‚Œã¾ã—ãŸ');
                  // Clear all caches first
                  caches.keys().then(cacheNames => {
                    return Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                  }).then(() => {
                    // Force reload without user confirmation
                    window.location.reload(true);
                  });
                }
              });
            });
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }

    // Online/Offline status
    function updateOnlineStatus() {
      const statusElement = document.getElementById('offline-status');
      if (navigator.onLine) {
        statusElement.textContent = 'ğŸŸ¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³';
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.textContent = 'ğŸ”´ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
        statusElement.style.color = '#F44336';
      }
    }

    // Update status on page load and network changes
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    window.addEventListener('load', updateOnlineStatus);

    window.addEventListener("scroll", () => {
      const bottom = window.innerHeight + window.scrollY;
      const docHeight = document.body.offsetHeight;
      if (bottom >= docHeight - 100) {
        renderLimit += 40;
        renderTable();
      }
    });
    </script>

<div style="margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.05); border-top: 1px solid rgba(0,0,0,0.1); text-align: center; font-size: 0.85em; color: #666;">
  <p><strong>æ¨©åˆ©è¡¨è¨˜ãƒ»å…è²¬äº‹é …</strong></p>
  <p>ã€Œãƒ›ãƒ­ãƒ©ã‚¤ãƒ–ã€ã€Œhololiveã€ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ã®å•†æ¨™ã§ã™ã€‚</p>
  <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã¯æ ªå¼ä¼šç¤¾ã‚«ãƒãƒ¼ã¨ã¯ç„¡é–¢ä¿‚ã®éå…¬å¼ãƒ•ã‚¡ãƒ³ãƒ¡ã‚¤ãƒ‰ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
  <p>ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®è‘—ä½œæ¨©ã¯å„æ¨©åˆ©è€…ã«å¸°å±ã—ã¾ã™ã€‚</p>
  <p>ã“ã®ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã«ã‚ˆã‚Šç”Ÿã˜ãŸæå®³ã«ã¤ã„ã¦ã€ä½œæˆè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
  <p style="margin-top: 10px;">Â© 2025 Hololive Card Game Management Tool (éå…¬å¼)</p>
</div>

<script>
// âœ… Service Worker ã¨ã®é€šä¿¡æ©Ÿèƒ½
async function sendMessageToSW(type, data) {
  if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
    throw new Error('Service Worker not available');
  }
  
  return new Promise((resolve) => {
    const messageChannel = new MessageChannel();
    messageChannel.port1.onmessage = (event) => {
      resolve(event.data);
    };
    navigator.serviceWorker.controller.postMessage({ type, data }, [messageChannel.port2]);
  });
}

// âœ… ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
async function getVersionInfo() {
  return await sendMessageToSW('GET_VERSION_INFO');
}

// âœ… æ›´æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
async function getUpdateMessage() {
  return await sendMessageToSW('GET_UPDATE_MESSAGE');
}

// âœ… å¤ã„ãƒšãƒ¼ã‚¸ã‚’ãƒã‚§ãƒƒã‚¯
async function checkOutdatedPages() {
  return await sendMessageToSW('CHECK_OUTDATED_PAGES');
}

// âœ… æ›´æ–°ç¢ºèªæ©Ÿèƒ½ - ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
async function checkForUpdates() {
  const statusEl = document.getElementById('versionDisplay');
  if (!statusEl) return;
  
  try {
    statusEl.textContent = '[ç¢ºèªä¸­...]';
    statusEl.style.color = '#007acc';
    
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      const messageChannel = new MessageChannel();
      
      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šï¼ˆ10ç§’ï¼‰
      const timeout = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Service Worker timeout')), 10000)
      );
      
      // Service Workerã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å¾…æ©Ÿ
      const checkPromise = new Promise((resolve, reject) => {
        messageChannel.port1.onmessage = (event) => {
          if (event.data.type === 'SINGLE_PAGE_VERSION_RESPONSE') {
            resolve(event.data.data);
          } else if (event.data.type === 'SINGLE_PAGE_VERSION_ERROR') {
            reject(new Error(event.data.error));
          }
        };
      });
      
      // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®å˜ä¸€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯è¦æ±‚ã‚’é€ä¿¡
      navigator.serviceWorker.controller.postMessage(
        { type: 'CHECK_SINGLE_PAGE_VERSION', data: { page: 'holoca_skill_page.html' } },
        [messageChannel.port2]
      );
      
      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
      const versionCheckResult = await Promise.race([checkPromise, timeout]);
      
      if (versionCheckResult.hasUpdates && versionCheckResult.pageInfo) {
        const pageInfo = versionCheckResult.pageInfo;
        
        statusEl.innerHTML = `ğŸš€ æ›´æ–°åˆ©ç”¨å¯èƒ½`;
        statusEl.style.color = '#ff6b35';
        
        // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã¿ã®è©³ç´°æƒ…å ±ã‚’ç”Ÿæˆ
        let detailMessage = `ğŸš€ ${pageInfo.page} ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸ä¸€è‡´ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ:\n\n`;
        detailMessage += `ğŸ“Š æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.expectedVersion}\n`;
        detailMessage += `ğŸ“Š ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.actualVersion || 'ä¸æ˜'}\n`;
        detailMessage += `ğŸ“Š ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³: v${pageInfo.cachedVersion || 'ãªã—'}\n\n`;
        
        // ãƒŸã‚¹ãƒãƒƒãƒã®ç†ç”±ã‚’æ—¥æœ¬èªã§èª¬æ˜
        let reasonText = '';
        switch(pageInfo.reason) {
          case 'expected_vs_actual_mismatch':
            reasonText = 'æœŸå¾…ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
            break;
          case 'actual_vs_cached_mismatch':
            reasonText = 'å®Ÿéš›ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒä¸ä¸€è‡´';
            break;
          case 'actual_version_not_found':
            reasonText = 'å®Ÿéš›ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
            break;
          case 'no_cached_version':
            reasonText = 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“';
            break;
          default:
            reasonText = pageInfo.reason;
        }
        detailMessage += `ç†ç”±: ${reasonText}\n\n`;
        
        setTimeout(() => {
          if (confirm(detailMessage + 'ã“ã®ãƒšãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¦ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã‹ï¼Ÿ')) {
            // ã‚ˆã‚Šå¼·åŠ›ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å‡¦ç†
            console.log('Starting forced cache clear and update...');
            
            // Service Workerã«å¼·åˆ¶æ›´æ–°ã‚’è¦æ±‚
            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({ type: 'FORCE_UPDATE' });
            }
            
            // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¬ãƒ™ãƒ«ã§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
            if ('caches' in window) {
              caches.keys().then(cacheNames => {
                return Promise.all(cacheNames.map(cacheName => {
                  console.log('Deleting cache:', cacheName);
                  return caches.delete(cacheName);
                }));
              }).then(() => {
                console.log('All browser caches cleared');
                // Service Workerã®æ›´æ–°ã‚’å¾…ã¤
                return new Promise(resolve => setTimeout(resolve, 1000));
              }).then(() => {
                // ã‚ˆã‚Šå¼·åŠ›ãªãƒªãƒ­ãƒ¼ãƒ‰
                console.log('Performing hard reload...');
                if (window.location.reload) {
                  window.location.reload(true); // å¼·åˆ¶ãƒªãƒ­ãƒ¼ãƒ‰
                } else {
                  window.location.href = window.location.href + '?t=' + Date.now();
                }
              }).catch(error => {
                console.error('Cache clear failed, forcing reload anyway:', error);
                window.location.href = window.location.href + '?t=' + Date.now();
              });
            } else {
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥APIãŒä½¿ãˆãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
              window.location.href = window.location.href + '?t=' + Date.now();
            }
          } else {
            // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å†è¡¨ç¤º
            displayVersionInfo();
          }
        }, 2000);
      } else {
        statusEl.innerHTML = `âœ… æœ€æ–° v${versionCheckResult.expectedVersion}`;
        statusEl.style.color = '#4caf50';
        setTimeout(() => {
          displayVersionInfo();
        }, 3000);
      }
      
    } else {
      statusEl.textContent = '[v3.8.0-SW-UNAVAILABLE]';
      statusEl.style.color = '#f44336';
    }
    
  } catch (error) {
    console.error('Update check failed:', error);
    statusEl.textContent = '[v3.8.0-ERROR: ' + error.message + ']';
    statusEl.style.color = '#f44336';
    setTimeout(() => {
      displayVersionInfo();
    }, 5000);
  }
}

// âœ… ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
async function displayVersionInfo() {
  const statusEl = document.getElementById('versionDisplay');
  if (!statusEl) return;
  
  try {
    const versionInfo = await getVersionInfo();
    if (versionInfo && versionInfo.data) {
      statusEl.textContent = `[v${versionInfo.data.pageVersions['holoca_skill_page.html']}-CENTRALIZED]`;
    }
  } catch (error) {
    console.warn('Version display error:', error);
    statusEl.textContent = '[v3.8.0-CENTRALIZED]';
  }
}

// âœ… ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
document.addEventListener('DOMContentLoaded', function() {
  // Service Worker ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—ã—ã¦è¡¨ç¤º
  setTimeout(() => {
    displayVersionInfo();
  }, 1000);
});

// âœ… Service Workerç™»éŒ²
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(function(registration) {
    console.log('Service Worker registered successfully:', registration.scope);
  }).catch(function(error) {
    console.log('Service Worker registration failed:', error);
  });
}
</script>

  </body>
</html>
